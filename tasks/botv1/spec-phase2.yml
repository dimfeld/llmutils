goal: Implement Phase 2 of the LLMUtils Bot System, focusing on enabling the AI
  to implement generated plans, create Pull Requests, manage workspaces via a
  database, track progress, and store/retrieve logs.
details: >
  This phase builds upon the existing Phase 1 (plan generation, basic bot
  commands, DB setup) by adding the core execution capabilities. Key
  deliverables include:

  1.  **Implementation Workflow**: A system for taking a task plan (YAML) and
  executing it using `rmplan agent`.

  2.  **PR Creation**: Automated creation of GitHub Pull Requests upon
  successful implementation.

  3.  **Workspace Management**: Migration of workspace tracking from JSON files
  to the SQLite database, and integration into the task lifecycle, including
  workspace locking by task.

  4.  **Progress Tracking**: Real-time updates on step completion posted to
  GitHub/Discord.

  5.  **Log Storage & Retrieval**: Storing detailed execution logs in the
  database and providing a Discord command (`/rm-logs`) to retrieve them. New
  bot commands (`@bot implement`, `/rm-implement`, `/rm-status`, `/rm-logs`)
  will be added.


  The project will follow an iterative approach, starting with database
  modifications for workspace management, then building the implementation
  workflow, integrating PR creation, and finally adding comprehensive logging
  and progress tracking features.
tasks:
  - title: Update Database Schema and Create Migrations for Workspaces
    description: >
      This task focuses on updating the SQLite database schema to support
      enhanced workspace management as per the project plan. It involves adding
      a new `workspaces` table to track workspace metadata and adding a `branch`
      column to the existing `tasks` table for better task-branch association. A
      new Drizzle ORM migration file will be generated and applied.
    files:
      - src/bot/db/schema.ts
      - src/bot/db/migrations/
    include_imports: false
    include_importers: false
    steps:
      - prompt: >
          Modify `src/bot/db/schema.ts` to include a new table named
          `workspaces`. This table should store metadata for task workspaces.


          The `workspaces` table should have the following columns:

          - `id`: Text, primary key (use a UUID, generated by the application).

          - `taskId`: Text, foreign key referencing `tasks.id`. This field
          should not be nullable.

          - `repositoryUrl`: Text, storing the URL of the cloned repository.
          This field should not be nullable.

          - `workspacePath`: Text, storing the absolute file system path to the
          workspace. This field should not be nullable and should be unique.

          - `branch`: Text, storing the name of the git branch created in the
          workspace. This field should not be nullable.

          - `originalPlanFile`: Text, storing the path to the plan file that
          this workspace was created for.

          - `createdAt`: Integer (timestamp mode), defaults to current
          timestamp. This field should not benullable.

          - `lastAccessedAt`: Integer (timestamp mode), should be updatable.

          - `lockedByTaskId`: Text, foreign key referencing `tasks.id`. This
          field can be nullable and indicates which task currently holds a lock
          on this workspace.


          Also, modify the existing `tasks` table schema in
          `src/bot/db/schema.ts`:

          - Add a new column `branch`: Text, nullable. This will store the
          branch name associated with the task if it operates within a specific
          branch (e.g., an implementation task creating a feature branch).


          Ensure all necessary imports from `drizzle-orm/sqlite-core` and
          `drizzle-orm` are used.
        done: true
      - prompt: >
          After modifying `src/bot/db/schema.ts` in the previous step, generate
          a new database migration file using Drizzle Kit.


          The command to generate the migration should be something like:

          `bun drizzle-kit generate --schema src/bot/db/schema.ts --out
          src/bot/db/migrations`


          Verify the generated SQL in the new migration file within the
          `src/bot/db/migrations/` directory. The migration should:

          1. Create the `workspaces` table with all specified columns, types,
          constraints (primary key, foreign keys, not null, unique, default
          values).
              - `id` as TEXT PRIMARY KEY
              - `task_id` as TEXT NOT NULL, with a FOREIGN KEY constraint referencing `tasks(id)`
              - `repository_url` as TEXT NOT NULL
              - `workspace_path` as TEXT NOT NULL UNIQUE
              - `branch` as TEXT NOT NULL
              - `original_plan_file` as TEXT
              - `created_at` as INTEGER DEFAULT (current_timestamp) NOT NULL
              - `last_accessed_at` as INTEGER
              - `locked_by_task_id` as TEXT, with a FOREIGN KEY constraint referencing `tasks(id)`
          2. Add the `branch` column (TEXT, nullable) to the existing `tasks`
          table using `ALTER TABLE`.


          Place the generated SQL migration file content into the appropriate
          new file in `src/bot/db/migrations/`. Update
          `src/bot/db/migrations/meta/_journal.json` accordingly (Drizzle Kit
          should handle this).

          If Drizzle Kit generates a different SQL structure for adding a column
          (e.g. by recreating the table for older SQLite), ensure it preserves
          data. However, for adding a nullable column, `ALTER TABLE ADD COLUMN`
          is standard.
        done: true
      - prompt: >
          Update the `src/bot/db/test-migrate.ts` and `src/bot/db/migrate.ts`
          scripts to ensure they correctly apply the new migration. No actual
          code changes should be needed in these files if they are generic, but
          it's good to verify they would run the new migration.


          Specifically, ensure that the `migrate` function from
          `drizzle-orm/better-sqlite3/migrator` is called with the correct
          `migrationsFolder` path.

          Then, update `src/bot/db/test-db.ts` to perform a simple query on the
          new `workspaces` table (e.g.,
          `db.select().from(workspaces).limit(1).all()`) to verify its existence
          after migration. Log the result of this query.

          Make sure to import the `workspaces` table schema into
          `src/bot/db/test-db.ts`.
        done: true
  - title: Adapt Workspace Tracker to Use Database
    description: >
      This task involves refactoring `src/rmplan/workspace/workspace_tracker.ts`
      to use the SQLite database (via the new `workspaces` table) for storing
      and retrieving workspace information, instead of the current JSON
      file-based tracking system. Functions like `recordWorkspace`,
      `findWorkspacesByRepoUrl`, `findWorkspacesByTaskId`, and
      `getWorkspaceMetadata` will be updated. JSON-specific helper functions
      will be removed or deprecated.
    files:
      - src/rmplan/workspace/workspace_tracker.ts
      - src/bot/db/index.ts
      - src/bot/db/schema.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/rmplan/workspace/workspace_tracker.ts`:

          1.  Import the `db` instance and the `workspaces as workspacesTable`
          schema from `src/bot/db/index.ts`. Also import `eq, desc, sql` from
          `drizzle-orm`.

          2.  Remove the `getDefaultTrackingFilePath`, `readTrackingData`, and
          `writeTrackingData` functions as they are for JSON file tracking.

          3.  Update the `WorkspaceInfo` interface:
              -   Add `id: string` (for the workspace record's UUID).
              -   Change `lockedBy?: { pid: number; startedAt: string; hostname: string; }` to `lockedByTaskId?: string | null`. This aligns with the new DB schema.
              -   Add `lastAccessedAt?: string | Date | null`.
        done: true
      - prompt: >
          In `src/rmplan/workspace/workspace_tracker.ts`, refactor the
          `recordWorkspace` function:

          1.  Change its signature: it should accept an object that matches the
          fields needed for the `workspaces` table (excluding `id` which will be
          generated, and `lastAccessedAt` which can be set initially or updated
          separately). Let's call this input `WorkspaceRecordData`.
              `WorkspaceRecordData` should include: `taskId`, `repositoryUrl`, `workspacePath`, `branch`, `originalPlanFile`. `createdAt` will be handled by DB default.
          2.  Generate a UUID for the `id` field of the new workspace record.

          3.  Instead of writing to a JSON file, insert a new record into the
          `workspacesTable` using `db.insert()`. Map fields from
          `WorkspaceRecordData` to the table columns. `createdAt` and
          `lastAccessedAt` can be set to `new Date()`.

          4.  The function should return the `id` of the newly created workspace
          record.

          5.  Update logging messages to reflect database operations.
        done: true
      - prompt: >
          In `src/rmplan/workspace/workspace_tracker.ts`, refactor the
          `getWorkspaceMetadata` function:

          1.  It should take `workspacePath: string` as input.

          2.  Query the `workspacesTable` for a record where `workspacePath`
          matches the input.

          3.  Return the `WorkspaceInfo` object if found, mapping DB fields to
          `WorkspaceInfo` fields (including the new `id` and `lockedByTaskId`,
          `lastAccessedAt`), otherwise return `null`.
        done: true
      - prompt: >
          In `src/rmplan/workspace/workspace_tracker.ts`, refactor
          `findWorkspacesByTaskId` function:

          1.  It should take `taskId: string` as input.

          2.  Query the `workspacesTable` for all records where `taskId` matches
          the input.

          3.  Return an array of `WorkspaceInfo` objects, mapping DB fields.
        done: true
      - prompt: >
          In `src/rmplan/workspace/workspace_tracker.ts`, refactor
          `findWorkspacesByRepoUrl` function:

          1.  It should take `repositoryUrl: string` as input.

          2.  Query the `workspacesTable` for all records where `repositoryUrl`
          matches (case-insensitive or normalized if possible, though simple
          exact match is fine for now).

          3.  Return an array of `WorkspaceInfo` objects, mapping DB fields.
        done: true
      - prompt: >
          In `src/rmplan/workspace/workspace_tracker.ts`, review and update the
          `updateWorkspaceLockStatus` function:

          1.  The `WorkspaceInfo` type has changed (`lockedBy` to
          `lockedByTaskId`). This function's primary role was to check the
          `.rmplan.lock` file and update `lockedBy` based on PID.

          2.  The DB now stores `lockedByTaskId`. The file-based PID lock
          (`.rmplan.lock`) managed by `WorkspaceLock.ts` can still exist as a
          low-level mutex for a physical path.

          3.  This function should now primarily:
              -   Accept `WorkspaceInfo[]` (which already has `lockedByTaskId` from the DB).
              -   For each workspace, it can still check the `.rmplan.lock` file using `WorkspaceLock.getLockInfo()` and `WorkspaceLock.isLockStale()`.
              -   The purpose of `updateWorkspaceLockStatus` becomes less about *updating* the DB lock status (that's managed elsewhere) and more about *enriching* the `WorkspaceInfo` with the *current file-system lock status* if needed for display or diagnostics.
              -   Modify `WorkspaceInfo` to optionally hold the file-system lock info: `fileSystemLock?: { pid: number; startedAt: string; hostname: string; } | null;`
              -   Populate `fileSystemLock` in the returned `WorkspaceInfo[]`.
              -   The DB `lockedByTaskId` remains the primary indicator of application-level locking.
          4. Update `lastAccessedAt` for each workspace in the database to the
          current time. This can be a new function `touchWorkspace(workspaceId:
          string)` or `touchWorkspaces(workspaceIds: string[])`. Call this
          function from `updateWorkspaceLockStatus` or ensure it's called
          whenever workspaces are accessed/listed. For now, let's make
          `updateWorkspaceLockStatus` update `lastAccessedAt` for all workspaces
          it processes.
        done: true
  - title: Update Workspace Manager and Auto-Selector for DB Integration
    description: >
      This task adapts `workspace_manager.ts` and `workspace_auto_selector.ts`
      to work with the new database-backed workspace tracking. `createWorkspace`
      will now use the new `recordWorkspace` that writes to the DB.
      `WorkspaceAutoSelector` will use the updated DB-based finders. Locking
      logic will also need to consider `lockedByTaskId`.
    files:
      - src/rmplan/workspace/workspace_manager.ts
      - src/rmplan/workspace/workspace_auto_selector.ts
      - src/rmplan/workspace/workspace_tracker.ts
      - src/rmplan/workspace/workspace_lock.ts
      - src/bot/db/index.ts
      - src/bot/config.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/rmplan/workspace/workspace_manager.ts`:

          1.  Import `db` and `workspacesTable`, `tasksTable`, `eq`, `sql` from
          `src/bot/db/index.ts` and `drizzle-orm`.

          2.  Update the `createWorkspace` function:
              -   It still takes `mainRepoRoot`, `taskId`, `originalPlanFilePath`, `config`.
              -   After successfully cloning the repository and setting up the branch, it should call the new DB-backed `recordWorkspace` from `workspace_tracker.ts`.
                  -   The data passed to `recordWorkspace` should include `taskId` (this is the task *initiating* the workspace creation), `repositoryUrl`, `workspacePath`, `branch`, `originalPlanFilePath`.
              -   The `createWorkspace` function should now also handle the application-level lock. When a workspace is newly created for a `taskId`, it should be considered locked by that `taskId`.
                  -   Update the `workspaces` table entry for the newly created workspace, setting `lockedByTaskId` to the `taskId` that initiated its creation.
              -   The `Workspace` interface returned by `createWorkspace` might need to be aligned with `WorkspaceInfo` from `workspace_tracker.ts` or simply return the path and new workspace ID. For now, ensure it returns at least `{ path: string, id: string, taskId: string }`.
              -   Remove any references to `config.paths.trackingFile` or `getDefaultTrackingFilePath` for recording, as this is now handled by `recordWorkspace` internally.
              -   The file-system lock (`WorkspaceLock.acquireLock`) should still be acquired using the PID of the current bot process if `rmplan agent` is to be run directly by the bot. The `command` for `acquireLock` can be `bot-task:${taskId}`.
        done: true
      - prompt: >
          In `src/rmplan/workspace/workspace_auto_selector.ts`:

          1.  Import `db`, `workspacesTable`, `tasksTable`, `eq`, `sql`, `and`,
          `isNull` from `src/bot/db/index.ts` and `drizzle-orm`.

          2.  Remove usage of `config.paths.trackingFile` and
          `getDefaultTrackingFilePath`.

          3.  Update the `selectWorkspace` method:
              -   When finding existing workspaces for the repository using `findWorkspacesByRepoUrl`, these will now come from the DB and include `lockedByTaskId`.
              -   The sorting logic should prioritize workspaces where `lockedByTaskId` is NULL, then by `lastAccessedAt` (oldest first to reuse) or `createdAt` (newest first for fresh workspaces - let's go with newest `createdAt` for available ones).
              -   When checking if a workspace is available:
                  -   Primary check: `workspace.lockedByTaskId` should be NULL.
                  -   Secondary check (optional, for robustness): The file-system lock from `WorkspaceLock.isLockStale()` can still be checked if a `.rmplan.lock` file exists, to guard against orphaned file locks. If a file lock is stale but `lockedByTaskId` is set, it indicates an inconsistency to be logged.
              -   If an available workspace is found ( `lockedByTaskId` is NULL):
                  -   Lock it: Update its record in `workspacesTable` to set `lockedByTaskId` to the current `taskId` and `lastAccessedAt` to `new Date()`.
                  -   Acquire the file-system lock using `WorkspaceLock.acquireLock()`.
                  -   Return this workspace.
              -   If a workspace has a `lockedByTaskId` but its associated task in the `tasks` table is `completed` or `failed`, this lock can be considered stale.
                  -   Add logic to query the `tasks` table for the status of `lockedByTaskId`.
                  -   If the locking task is completed/failed, prompt the user (if interactive) or auto-clear `lockedByTaskId` (set to NULL) and the file-system lock. Then attempt to acquire it for the current task.
          4.  Update `handleStaleLock`: This method currently deals with
          PID-based file locks. It should be adapted or augmented. If
          `selectWorkspace` identifies a workspace locked by a *completed/failed
          task* (via `lockedByTaskId`), it should confirm clearing this
          *application-level* lock. Clearing the file-system lock via
          `WorkspaceLock.clearStaleLock` would follow.

          5.  The `createNewWorkspace` method will call the updated
          `createWorkspace` from `workspace_manager.ts`. The new workspace will
          already be locked to the `taskId` by `createWorkspace`.
        done: true
      - prompt: >
          In `src/rmplan/workspace/workspace_auto_selector.ts`:

          1.  Update `listWorkspacesWithStatus` static method:
              -   It should fetch workspaces using the DB-backed `findWorkspacesByRepoUrl`.
              -   The status display should primarily reflect `lockedByTaskId`. If `lockedByTaskId` is set, indicate which task has it locked.
              -   It can also show the file-system lock status (PID based) as secondary information if available.
              -   Information like `branch`, `createdAt`, `lastAccessedAt` should be fetched from the DB.
        done: false
      - prompt: >
          In `src/rmplan/agent.ts` (`rmplanAgent` function):

          1.  When handling `--auto-workspace` or `--workspace <id>`:
              -   It uses `WorkspaceAutoSelector` or `createWorkspace`. These are now DB-aware.
              -   The `workspace` object returned will contain the workspace ID from the DB.
              -   If a workspace is selected/created, its `lockedByTaskId` in the `workspaces` table should be set to the `taskId` of the *current agent execution*.
                  -   The `rmplanAgent` itself doesn't have a `taskId` *from the bot's `tasks` table* when run from CLI.
                  -   For bot usage, the `taskId` will come from the bot's `tasks` table.
                  -   When `rmplanAgent` is invoked by the bot for an implementation task, the bot will provide its `taskId`. This `taskId` should be used to lock the workspace.
                  -   The `WorkspaceLock.acquireLock` (file-based) should still use the PID.
              -   The `options.workspace` parameter in `rmplan agent` (CLI) often serves as a human-readable ID. For bot integration, a proper `bot_task_id` will be used. We need to ensure `rmplanAgent` can accept this `bot_task_id` to correctly manage the `lockedByTaskId` field.
              -   Modify `rmplanAgent` to accept an optional `botTaskId` parameter. If provided, this ID is used for `lockedByTaskId` in DB operations. If not (CLI usage), `lockedByTaskId` might be based on `options.workspace` or remain null if not creating a new workspace.
          2.  When `rmplanAgent` finishes (successfully or with error), it
          should release the workspace lock.
              -   This means setting `lockedByTaskId` to NULL in the `workspaces` table for the workspace it used.
              -   And calling `WorkspaceLock.releaseLock()` for the file-system lock.
              -   This should happen in a `finally` block to ensure release.
        done: false
  - title: Enhance Task Manager for Implementation Lifecycle
    description: >
      This task involves updating the `TaskManager` to handle the lifecycle of
      "implementation" tasks. This includes defining new task statuses, and
      creating a new method `startImplementationTask` which will find a plan,
      set up a workspace, and prepare to invoke `rmplanAgent`.
    files:
      - src/bot/core/task_manager.ts
      - src/bot/db/schema.ts
      - src/rmplan/workspace/workspace_auto_selector.ts
      - src/rmplan/workspace/workspace_manager.ts
      - src/bot/core/thread_manager.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/bot/core/task_manager.ts`:

          1.  Define a set of status strings for the implementation lifecycle.
          These could include:
              `'pending_implementation'` (initial state for a new implementation request)
              `'workspace_setup'` (workspace is being created/selected)
              `'implementing'` (rmplanAgent is running)
              `'implementation_complete'` (rmplanAgent finished successfully)
              `'implementation_failed'` (rmplanAgent failed)
              `'pr_pending'` (implementation complete, awaiting PR creation)
              `'pr_created'` (PR successfully created)
              `'pr_failed'` (PR creation failed)
              `'completed'` (overall task success)
              `'failed'` (overall task failure)
              Ensure these align with or extend the statuses mentioned in the project plan (`planning, implementing, pr_created, responding, completed, failed`).
          2.  Update the `CreateTaskOptions` interface to clearly distinguish
          between creating a 'plan' task and an 'implement' task. Maybe
          `taskType` is sufficient.

          3.  Add a new interface `StartImplementationOptions` which includes:
              - `platform`: 'github' | 'discord'
              - `userId`: string (initiator)
              - `issueUrl`: string (to find the original plan)
              - `repoFullName`: string
              - `repoPath`: string (local path to a clone of the repo, for `rmplan local operations`)
              - `originalCommandId?`: number (ID from `command_history` table)
              - `githubCommentId?`: number
              - `discordInteraction?`: any
        done: false
      - prompt: >
          In `src/bot/core/task_manager.ts`, create the `async
          startImplementationTask(options: StartImplementationOptions):
          Promise<string | null>` method.

          This method will:

          1.  Log the request and generate a new unique `taskId` (UUID) for this
          implementation task.

          2.  Find the latest successfully completed 'plan' task associated with
          `options.issueUrl`.
              - Query the `tasks` table for `taskType: 'plan'`, `issueUrl: options.issueUrl`, `status: 'plan_generated'`, ordered by `createdAt` descending.
              - If no such plan task is found, log an error, update `commandHistoryTable` (if `originalCommandId` is present) to 'failed', notify the user via `thread_manager.ts`, and return `null`.
              - Get the `planFilePath` from this found 'plan' task. This path is likely within the bot's own storage for plans.
          3.  Create a new task record in the `tasks` table for this
          implementation run:
              - `id`: new `taskId`
              - `issueUrl`: `options.issueUrl`
              - `issueNumber`: (parse from `options.issueUrl`)
              - `repositoryFullName`: `options.repoFullName`
              - `taskType`: `'implement'`
              - `status`: `'pending_implementation'`
              - `planFilePath`: The `planFilePath` obtained from the 'plan' task.
              - `createdByPlatform`: `options.platform`
              - `createdByUserId`: `options.userId`
              - `createdAt`: current time
              - `updatedAt`: current time
          4.  If `options.originalCommandId` exists, update the corresponding
          `commandHistoryTable` entry with the new `taskId` and set its status
          to `'processing'`.

          5.  Notify task creation via `thread_manager.notifyTaskCreation`
          indicating "Implementation task started for issue...".

          6.  Return the new `taskId`. The actual workspace creation and agent
          invocation will be handled by a subsequent step/function that
          processes tasks in `pending_implementation` or `workspace_setup`
          status.


          For now, this function sets up the task record. The execution part
          will be separate.
        done: false
      - prompt: >
          In `src/bot/core/task_manager.ts`, create a new method `async
          processImplementationTask(taskId: string): Promise<void>`. This method
          will be called (e.g., by a main loop or queue worker, simulation for
          now) to execute a task created by `startImplementationTask`.


          `processImplementationTask(taskId: string)` method:

          1.  Fetch the task by `taskId`. If not found or not an 'implement'
          task in a runnable state (e.g. `pending_implementation` or
          `workspace_setup`), log and return.

          2.  **Workspace Setup**:
              - Update task status to `'workspace_setup'`.
              - Use `WorkspaceAutoSelector` (from `src/rmplan/workspace/workspace_auto_selector.ts`) to select or create a workspace.
                  - The `taskId` for `WorkspaceAutoSelector.selectWorkspace` will be the current implementation `taskId`.
                  - The `planFilePath` needed by `WorkspaceAutoSelector` will be the `task.planFilePath` (which is the original plan's location).
                  - `WorkspaceAutoSelector` and `createWorkspace` are now DB-aware and will handle setting `lockedByTaskId`.
              - If workspace setup fails:
                  - Update task status to `'implementation_failed'` (or a more specific e.g. `'workspace_failed'`).
                  - Log the error message in `tasks.errorMessage`.
                  - Notify failure via `thread_manager`.
                  - Return.
              - On successful workspace setup:
                  - Get the `selectedWorkspacePath` and `branchName` (from `WorkspaceInfo.branch`).
                  - Update the task record with `workspacePath: selectedWorkspacePath`, `branch: branchName`, and status to `'implementing'`.
                  - Copy the original plan file (`task.planFilePath`) into the `selectedWorkspacePath`. The new path for the plan inside the workspace should be stored, perhaps in a temporary variable or if `rmplanAgent` needs it relative to workspace root.
          3.  **Agent Invocation placeholder**: For now, log that we would
          invoke `rmplanAgent` here with the `selectedWorkspacePath` and the
          path to the plan file *inside the workspace*. Update task status to a
          temporary `'awaiting_agent_completion'` (or directly to
          `'implementation_complete'` for this step if not doing full agent run
          yet).

          4.  Notify progress (e.g. "Workspace ready", "Starting
          implementation") via `thread_manager`.
        done: false
  - title: Integrate `rmplanAgent` Invocation and Basic Logging
    description: >
      This task modifies `taskManager.processImplementationTask` to actually
      invoke `rmplanAgent` for the implementation. It also includes basic
      logging of `rmplanAgent`'s full output to the `task_logs` table after its
      completion.
    files:
      - src/bot/core/task_manager.ts
      - src/rmplan/agent.ts
      - src/bot/db/schema.ts
      - src/bot/db/index.ts
      - src/logging.ts
      - src/rmfilter/utils.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/rmplan/agent.ts`, modify the `rmplanAgent` function:

          1.  Add a new optional parameter `botTaskId?: string` to its
          signature.

          2.  If `botTaskId` is provided and a workspace is being used/created:
              -   When acquiring the workspace lock via `WorkspaceAutoSelector` or `createWorkspace`, the `lockedByTaskId` in the `workspaces` table should be set using this `botTaskId`.
              -   When `WorkspaceLock.acquireLock` (file-based PID lock) is called, the command string can include `bot-task:${botTaskId}`.
          3.  Ensure that in the `finally` block where locks are released:
              -   If `botTaskId` was used to lock the workspace in the DB (`lockedByTaskId`), this DB lock is released (set `lockedByTaskId` to NULL).
              -   The file-based lock (`.rmplan.lock`) is also released as currently done.
          4.  The `rmplanAgent` function should be callable programmatically and
          return a Promise that resolves or rejects based on its success or
          failure. It might need to return an object `{ success: boolean,
          logOutput: string }`. For now, ensure it throws an error on failure.

          5. Make sure `rmplanAgent` is run non-interactively when called by the
          bot (e.g. using options like `--non-interactive` if it has them, or by
          not trying to prompt). The current `rmplanAgent` uses
          `inquirer/prompts` if `options.nonInteractive` is not set. The bot
          should always invoke it non-interactively. The options passed to
          `rmplanAgent` from `taskManager` should enforce this.
        done: false
      - prompt: >
          In `src/bot/core/task_manager.ts`, modify the
          `processImplementationTask` method:

          1.  After successful workspace setup and status is set to
          `'implementing'`:

          2.  Programmatically call the `rmplanAgent` function from
          `src/rmplan/agent.ts`.
              -   The `planFile` argument for `rmplanAgent` should be the path to the plan file *copied inside the workspace*.
              -   Pass necessary options to `rmplanAgent`:
                  -   `executor`: Use `'claude-code'` as default (per spec), or one from task/repo config.
                  -   `model`: From task/repo config.
                  -   `nonInteractive: true`.
                  -   `workspace: workspaceInfo.id` (the DB ID of the workspace record). This ensures `rmplanAgent` uses the correct workspace path.
                  -   `botTaskId: taskId` (the ID of the current 'implement' task).
              -   The `rmplanAgent` will run in the `workspaceInfo.path`. The `currentBaseDir` for `rmplanAgent` needs to be set to this workspace path.
          3.  Wrap the call to `rmplanAgent` in a try-catch block.
              -   On success: Update task status to `'implementation_complete'`.
              -   On failure (error thrown by `rmplanAgent`):
                  -   Update task status to `'implementation_failed'`.
                  -   Store the error message in `tasks.errorMessage`.
                  -   Log the error.
          4.  **Basic Logging**:
              -   The `rmplanAgent` function currently logs its output to a file if `!options['no-log']`.
              -   For bot integration, we need to capture its stdout and stderr.
              -   Modify `rmplanAgent` or how it's called:
                  -   One way is to have `rmplanAgent` accumulate its log messages (those currently sent to `log()`, `error()`, `warn()`) into a string buffer and return it.
                  -   Alternatively, if `rmplanAgent` uses `spawnAndLogOutput` for its sub-processes, `spawnAndLogOutput` already captures stdout/stderr. The `rmplanAgent` itself mostly orchestrates.
                  -   For now, let's assume `rmplanAgent` can be modified to return its full log output as a string. Or, temporarily, read the log file it creates (`<planName>-agent-output.md`).
              -   After `rmplanAgent` completes (success or fail), insert its entire captured output as a single entry into the `task_logs` table:
                  - `taskId`: current implementation task's ID.
                  - `logLevel`: `'info'` (for the whole agent run log).
                  - `message`: A summary like "rmplanAgent execution log".
                  - `fullContent`: The captured stdout/stderr string from `rmplanAgent`.
          5.  Notify completion/failure via `thread_manager`.
        done: false
  - title: Add Bot Commands for Implementation
    description: >
      Implement the `@bot implement` command for GitHub and `/rm-implement
      <issue-url>` for Discord. These commands will find an existing plan for
      the specified issue and trigger the new
      `taskManager.startImplementationTask` method.
    files:
      - src/bot/github_handler.ts
      - src/bot/discord_bot.ts
      - src/bot/core/task_manager.ts
      - src/bot/db/index.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/bot/github_handler.ts` (`processIssueComment` function):

          1.  Add a case for the command `'implement'`.

          2.  When `@bot implement` is detected:
              -   Log the command.
              -   The command might optionally take an issue URL as an argument (e.g., `@bot implement <issue-url>`). If no URL is provided, it defaults to the current issue (`payload.issue.html_url`).
              -   Determine `repoFullName` from the payload.
              -   Determine `repoPath` (local path to a clone of the repo, similar to how it's done for `@bot plan`). Ensure this path exists and is valid. If not, update `commandHistoryTable` to 'failed' and notify.
              -   Get `originalCommandId` (already available from initial command logging).
              -   Call `taskManager.startImplementationTask` with the necessary options:
                  - `platform: 'github'`
                  - `userId: payload.sender.login`
                  - `issueUrl`: target issue URL
                  - `repoFullName`: `payload.repository.full_name`
                  - `repoPath`: Determined local path to the repo clone.
                  - `githubCommentId: payload.comment.id`
                  - `originalCommandId: originalCommandId`
              -   The call to `startImplementationTask` is asynchronous. The webhook should return quickly.
        done: false
      - prompt: >
          In `src/bot/discord_bot.ts`:

          1.  Define a new slash command schema for `/rm-implement`:
              - Name: `rm-implement`
              - Description: "Implements an existing plan for a GitHub issue."
              - Option: `issue-url` (string, required, description: "The URL of the GitHub issue with an existing plan.")
          2.  Add this new command to the `commands` array for registration.

          3.  In the `interactionCreate` event handler:
              - Add a case for the `rm-implement` command.
              - Get the `issue-url` option.
              - Reply to the interaction to acknowledge receipt (e.g., "Processing /rm-implement for <issue-url>...").
              - Parse `repoFullName` from the `issue-url` using `parseGitHubIssueUrl`. If invalid, reply with an error and update `commandHistoryTable`.
              - Determine `repoPath` (e.g., `${config.WORKSPACE_BASE_DIR}/clones/${repoFullName}`). Verify its existence and validity. If not valid, reply with error and update `commandHistoryTable`.
              - Get `originalCommandId` (already available).
              - Call `taskManager.startImplementationTask` with options:
                  - `platform: 'discord'`
                  - `userId: interaction.user.id`
                  - `issueUrl`: from command option
                  - `repoFullName`: parsed from URL
                  - `repoPath`: determined local path
                  - `discordInteraction`: simplified interaction details (id, channelId, token)
                  - `originalCommandId: originalCommandId`
              - This call is asynchronous. The interaction reply should be handled appropriately (e.g., `deferReply` then `editReply` or `followUp` if `startImplementationTask` takes too long for an initial reply, though `startImplementationTask` itself is quick, the processing is separate).
        done: false
  - title: Develop PR Creation Utility
    description: >
      Create a utility (class or set of functions) that handles the Git
      operations (commit, push) in a completed workspace and then creates a
      GitHub PullRequest using Octokit.
    files:
      - src/bot/utils/pr_creator.ts
      - src/common/github/issues.ts
      - src/rmpr/git_utils.ts
      - src/bot/core/task_manager.ts
      - src/bot/db/schema.ts
      - src/bot/config.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/rmpr/git_utils.ts`:

          1.  Add a new function `async pushBranch(branchName: string,
          workspacePath: string, remoteName: string = 'origin'):
          Promise<{success: boolean, error?: string}>`.
              - This function should execute `git push ${remoteName} ${branchName}` in the `workspacePath`.
              - It should handle success and failure, returning appropriate status.
          2.  Add a new function `async getCurrentBranch(workspacePath: string):
          Promise<string | null>` that runs `git rev-parse --abbrev-ref HEAD` in
          `workspacePath`.

          3.  Add a new function `async commitChanges(workspacePath: string,
          message: string): Promise<{success: boolean, error?: string}>`. This
          can use or adapt logic from `commitAll` but be specific to a workspace
          path and ensure it only commits if there are changes. `git commit -am
          "${message}"`.
        done: false
      - prompt: >
          Create a new file `src/bot/utils/pr_creator.ts`.

          Define an interface `PRCreationOptions`:

          - `taskId`: string (the bot's implementation task ID)

          - `workspacePath`: string

          - `issueNumber`: number

          - `repositoryFullName`: string (e.g., "owner/repo")

          - `issueTitle`: string

          - `planMarkdownContent?`: string (optional, content of the original
          plan)

          - `discordThreadUrl?`: string (optional, link to Discord discussion
          thread)


          Create a class `PRCreator` or a function `async
          createPullRequest(options: PRCreationOptions): Promise<{ prNumber?:
          number; prUrl?: string; error?: string }>`

          This function/method should:

          1.  Initialize Octokit using `config.GITHUB_TOKEN`.

          2.  Get the current branch name in the `workspacePath` using
          `git_utils.getCurrentBranch()`. If not found, error.

          3.  **Commit any remaining changes**: (Optional, as `rmplanAgent`
          should commit steps. A final "tidy up" commit might be useful.)
              - Use `git_utils.commitChanges(workspacePath, "Finalizing changes from AI implementation.")`. If this fails but there are no actual changes to commit, it's okay.
          4.  **Push the branch**:
              - Use `git_utils.pushBranch(branchName, workspacePath)`. If push fails, return an error.
          5.  **Create Pull Request**:
              -   `owner` and `repo` can be parsed from `repositoryFullName`.
              -   `title`: Use `options.issueTitle` prefixed with something like "AI: " or "[BOT] ".
              -   `head`: The branch name pushed from the workspace.
              -   `base`: The target branch (e.g., 'main' or 'master'). This needs to be determined. It could be fetched from the original issue's repository default branch or the base branch of the PR if the issue was a PR. For now, assume 'main'. This needs to be configurable or fetched. (Fetch default branch of the repo: `octokit.rest.repos.get({ owner, repo })` then `default_branch`).
              -   `body`: Construct a PR body. Include:
                  -   A link to the original GitHub issue (e.g., `Resolves #${options.issueNumber}`).
                  -   If `options.planMarkdownContent` is provided, include a summary or link to it.
                  -   If `options.discordThreadUrl` is provided, include a link.
                  -   Mention it was created by the LLMUtils bot.
              -   Use `octokit.rest.pulls.create()`.
          6.  If PR creation is successful, return `prNumber` and `prUrl`.

          7.  If any step fails, return an `error` message.
        done: false
  - title: Integrate PR Creation into Task Manager
    description: >
      Modify `TaskManager.processImplementationTask` to call the new `PRCreator`
      utility after a successful implementation. The task's status and
      `pr_number` field will be updated accordingly, and notifications sent out.
    files:
      - src/bot/core/task_manager.ts
      - src/bot/utils/pr_creator.ts
      - src/bot/db/schema.ts
      - src/bot/db/index.ts
      - src/bot/core/thread_manager.ts
      - src/common/github/issues.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/bot/core/task_manager.ts`:

          1.  Import `createPullRequest` (or `PRCreator`) from
          `src/bot/utils/pr_creator.ts`.

          2.  Import `getInstructionsFromGithubIssue` from
          `src/common/github/issues.ts` (or a simpler issue fetcher if only
          title is needed).

          3.  Modify the `processImplementationTask` method:
              -   After `rmplanAgent` completes successfully and task status is updated to `'implementation_complete'`, proceed to PR creation.
              -   Update task status to `'pr_pending'`.
              -   Fetch original issue details (specifically title) using `octokit.rest.issues.get()` or a helper for `task.issueUrl`.
              -   Fetch related Discord thread URL for this task from `threadsTable` if available.
              -   Fetch original plan content. The `task.planFilePath` points to the original plan. Read its content.
              -   Call `createPullRequest` with the required options:
                  -   `taskId`: current task's ID
                  -   `workspacePath`: `task.workspacePath`
                  -   `issueNumber`: `task.issueNumber`
                  -   `repositoryFullName`: `task.repositoryFullName`
                  -   `issueTitle`: Fetched issue title
                  -   `planMarkdownContent`: Content of the original plan file.
                  -   `discordThreadUrl`: Fetched Discord thread URL for the task.
              -   Handle the result from `createPullRequest`:
                  -   If successful (`prNumber` and `prUrl` are returned):
                      -   Update the task record in DB: set `prNumber`, status to `'pr_created'`, and `updatedAt`.
                      -   Log success and the PR number/URL.
                      -   Notify via `thread_manager.notifyTaskCreation` (or a new `notifyPrCreated`) about the new PR, including its URL.
                  -   If failed (`error` message returned):
                      -   Update task status to `'pr_failed'`.
                      -   Store the error in `tasks.errorMessage`.
                      -   Log the failure.
                      -   Notify failure via `thread_manager`.
        done: false
  - title: Implement Database Logger for `rmplanAgent`
    description: >
      Create a `DatabaseLoggerAdapter` that writes log entries to the
      `task_logs` SQLite table. This adapter will be used within `TaskManager`
      to capture detailed logs specifically from `rmplanAgent` executions,
      associating them with the correct `taskId`.
    files:
      - src/logging/adapters/database_logger_adapter.ts
      - src/logging/adapter.ts
      - src/bot/core/task_manager.ts
      - src/bot/db/index.ts
      - src/rmplan/agent.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          Create a new file `src/logging/adapters/database_logger_adapter.ts`.

          In this file, define a class `DatabaseLoggerAdapter` that implements
          the `LoggerAdapter` interface from `src/logging/adapter.ts`.


          The constructor should take `taskId: string` and `db` (Drizzle
          instance) as arguments.

          Store `taskId` and `db` as private members.


          Implement the `LoggerAdapter` methods (`log`, `error`, `warn`,
          `debugLog`):

          - Each method should create a log entry object with:
              - `taskId`: The stored `taskId`.
              - `logLevel`: 'info', 'error', 'warn', 'debug' respectively.
              - `message`: Concatenate all arguments into a string (e.g., using `util.inspect` for objects, similar to `ConsoleAdapter`).
              - `fullContent`: Optional. If an argument is very large or represents structured data that shouldn't be truncated in `message`, it can be stored here (e.g., stringified JSON). For now, `message` can contain the full formatted string and `fullContent` can be null.
              - `timestamp`: Will be set by DB default.
          - Insert this log entry into the `taskLogs` table using
          `this.db.insert(taskLogsTable).values(...)`.

          - Handle potential errors during DB insertion gracefully (e.g., log to
          console as a fallback).


          The `writeStdout` and `writeStderr` methods can also log to the DB
          with a specific `logLevel` (e.g., 'stdout', 'stderr') or be combined
          into the `message` field of regular `log` calls if that's simpler. For
          now, let them log with level 'info', prefixing the message with
          "STDOUT:" or "STDERR:".
        done: false
      - prompt: >
          In `src/bot/core/task_manager.ts` (`processImplementationTask`
          method):

          1.  Import `DatabaseLoggerAdapter` from
          `src/logging/adapters/database_logger_adapter.ts`.

          2.  Import `runWithLogger` from `src/logging/adapter.ts`.

          3.  Import `db` from `src/bot/db/index.ts`.

          4.  When invoking `rmplanAgent`:
              -   Create an instance of `DatabaseLoggerAdapter` with the current `taskId` and the `db` instance.
              -   Wrap the call to `rmplanAgent` (and any directly related pre/post logging for that specific agent run) inside `runWithLogger(databaseLoggerAdapter, async () => { ... })`.
          5.  This replaces the previous "Basic Logging" step where
          `rmplanAgent`'s entire output was stored as a single log entry. Now,
          individual log calls from within `rmplanAgent` (if it uses the global
          `log`, `error` functions from `src/logging.ts`) will be captured by
          the `DatabaseLoggerAdapter`.


          To make this effective, `rmplanAgent` in `src/rmplan/agent.ts` needs
          to use the shared `log`, `error`, `warn`, `debugLog` functions from
          `src/logging.ts` for its own logging, instead of `console.log` or
          direct file writes (or its file writes for `-agent-output.md` should
          be disabled when run by bot). The `openLogFile`/`closeLogFile`
          mechanism in `rmplanAgent` might conflict or be redundant if
          `DatabaseLoggerAdapter` is used.

          Review `src/rmplan/agent.ts`:

          - It uses `openLogFile` and `closeLogFile`.

          - It uses `log`, `error`, `warn` from `src/logging.ts`.

          - When `rmplanAgent` is called by the bot, the `options['no-log']`
          should be true to prevent file logging, relying instead on
          `DatabaseLoggerAdapter`.

          - Ensure `rmplanAgent` options passed from `task_manager` include
          `noLog: true` (or equivalent based on actual option name).
        done: false
  - title: Implement Log Retrieval Command
    description: >
      Add the `/rm-logs <task-id>` Discord command to allow users to retrieve
      and view logs for a specific task from the `task_logs` table.
    files:
      - src/bot/discord_bot.ts
      - src/bot/db/index.ts
      - drizzle-orm
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/bot/discord_bot.ts`:

          1.  Define a new slash command schema for `/rm-logs`:
              - Name: `rm-logs`
              - Description: "Retrieves execution logs for a specific task."
              - Option: `task-id` (string, required, description: "The ID of the task to retrieve logs for.")
          2.  Add this new command to the `commands` array for registration.

          3.  In the `interactionCreate` event handler:
              - Add a case for the `rm-logs` command.
              - Get the `task-id` option.
              - Acknowledge the interaction (e.g., `deferReply` or an initial reply).
              - Query the `task_logs` table for all entries where `taskId` matches the input `task-id`, ordered by `timestamp` ascending.
              - Format the logs for display. Each log entry should ideally show `timestamp`, `logLevel`, and `message`.
              - Discord messages have a character limit (2000). If the formatted logs exceed this, either:
                  - Paginate the logs into multiple messages.
                  - Send the logs as a text file attachment.
                  - For MVP, send the first N lines or characters, and indicate if truncated.
              Let's go with sending as a text file if logs are too long. If short enough, send in a code block.
              - Send the formatted logs as a reply (e.g., `editReply` or `followUp`).
              - Handle cases where the `task-id` is not found or has no logs.
              - Update `commandHistoryTable` for this command's execution (success/failure).
        done: false
  - title: Real-time Step Progress Reporting
    description: >
      Modify `rmplan agent`'s `markStepDone` to support a callback for reporting
      progress. `TaskManager` will use this to send real-time step completion
      updates to GitHub/Discord via `ThreadManager`. Also includes updating
      GitHub comments in-place with overall task status.
    files:
      - src/rmplan/actions.ts
      - src/bot/core/task_manager.ts
      - src/bot/core/thread_manager.ts
      - src/bot/db/schema.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/rmplan/actions.ts` (`markStepDone` function):

          1.  Add an optional parameter `progressCallback?: (details: {
          taskIndex: number; stepIndex: number; stepPrompt: string; taskTitle:
          string; planFile: string }) => Promise<void>` to the function
          signature.

          2.  Inside `markStepDone`, after determining which step(s) are being
          marked done and before writing the updated plan file:
              -   If `progressCallback` is provided, invoke it for each step being marked as done.
              -   Pass an object containing `taskIndex` (relative to plan tasks array), `stepIndex` (relative to task steps array), `stepPrompt` (the prompt of the completed step), `taskTitle` (title of the current task), and `planFile` (path to the plan file being modified).
        done: false
      - prompt: >
          In `src/bot/core/thread_manager.ts`:

          1.  Add a new function `async notifyTaskProgress(taskId: string,
          progressMessage: string, taskStatus?: string): Promise<void>`.

          2.  This function should:
              -   Fetch all associated threads (GitHub and Discord) for the given `taskId` from the `threads` table.
              -   For each Discord thread, post the `progressMessage`.
              -   For each GitHub thread (issue comment):
                  -   If `taskStatus` is provided, try to find the *initial bot comment* that announced task creation for this `taskId` (its `external_id` would be stored in `threads` table).
                  -   If found, *edit* that comment to append the new `progressMessage` and update the overall status. For example: "Task XYZ: Planning started... \nUpdate: Step 1/5 complete. Current Status: Implementing".
                  -   If not found, or if editing is too complex for MVP, post a *new* comment with the `progressMessage`. (Let's start with posting a new comment, and note that in-place updates are a future enhancement, unless simple to add).
                  -   The project plan specifically asks for "GitHub comments updated in-place with status". So, attempt to edit the original bot comment. The `threads` table stores `external_id` which is the GitHub comment ID for GitHub threads.
              -   Requires `octokit.rest.issues.updateComment()` and `discordClient` channel/thread message sending.
        done: false
      - prompt: >
          In `src/bot/core/task_manager.ts` (`processImplementationTask`
          method):

          1.  When preparing to call `rmplanAgent`, define a `progressCallback`
          function.

          2.  This callback will receive `details: { taskIndex, stepIndex,
          stepPrompt, taskTitle, planFile }` from `markStepDone`.

          3.  Inside the callback, construct a progress message, e.g., `Task
          ${taskTitle} (in ${planFile}): Step ${stepIndex + 1}
          "${stepPrompt.substring(0,50)}..." completed.`.

          4.  Call `threadManager.notifyTaskProgress(taskId, progressMessage,
          currentTaskStatus)` where `taskId` is the ID of the 'implement' task.

          5.  Pass this `progressCallback` to `rmplanAgent` as part of its
          options.

          6.  `rmplanAgent` in `src/rmplan/agent.ts` needs to be modified to
          accept this `progressCallback` in its options and pass it down to
          `markStepDone`.


          Modify `rmplanAgent` in `src/rmplan/agent.ts`:

          - Add `progressCallback` to its `options` parameter type.

          - When calling `markStepDone` within `rmplanAgent`, pass this
          `progressCallback` through.
        done: false
      - prompt: >
          In `src/bot/core/task_manager.ts`:

          Refine notifications for overall task status changes in
          `startPlanGenerationTask`, `startImplementationTask`, and
          `processImplementationTask`.

          Whenever a major status update happens (e.g., `planning`,
          `implementing`, `implementation_complete`, `pr_created`, `failed`),
          call `threadManager.notifyTaskProgress(taskId, "Overall status:
          <new_status>", new_status)` in addition to specific messages. This
          will ensure the in-place GitHub comment gets updated with the latest
          overall status.
        done: false
  - title: Implement Task Status Command
    description: >
      Add the `/rm-status [task-id]` Discord command to allow users to query the
      current status of a task (or their most recent task if ID is omitted).
    files:
      - src/bot/discord_bot.ts
      - src/bot/db/index.ts
      - drizzle-orm
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/bot/discord_bot.ts`:

          1.  Define a new slash command schema for `/rm-status`:
              - Name: `rm-status`
              - Description: "Checks the status of a task."
              - Option: `task-id` (string, optional, description: "The ID of the task to check. Omitting it shows your most recent task.")
          2.  Add this new command to the `commands` array for registration.

          3.  In the `interactionCreate` event handler:
              - Add a case for the `rm-status` command.
              - Get the optional `task-id` option and the `interaction.user.id`.
              - Acknowledge the interaction.
              - If `task-id` is provided:
                  - Query the `tasks` table for the task with that ID.
              - If `task-id` is NOT provided:
                  - Query the `tasks` table for the most recent task created by `interaction.user.id` (i.e., `where(eq(tasks.createdByUserId, userId)).orderBy(desc(tasks.createdAt)).limit(1)`).
              - If a task is found:
                  - Format a message with key task details: ID, Type, Status, Issue URL, PR Number (if any), Created At, Updated At.
                  - Reply with the formatted status.
              - If no task is found (for the given ID or for the user), reply accordingly.
              - Update `commandHistoryTable` for this command's execution.
        done: false
  - title: (Stretch) Capture `TodoWrite` from Claude Code Executor
    description: >
      Enhance the `ClaudeCodeExecutor` to parse its JSON stream output,
      specifically identifying `TodoWrite` tool calls (or a similar, more
      generic file write/edit tool used by Claude Code). These identified
      operations should be logged distinctly via the `DatabaseLoggerAdapter` for
      better progress visibility.
    files:
      - src/rmplan/executors/claude_code.ts
      - src/logging/adapter.ts
      - src/logging/adapters/database_logger_adapter.ts
      - src/logging.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/rmplan/executors/claude_code.ts`:

          1.  Modify the `formatJsonMessage` function (or the logic within
          `execute` that processes the stream if `formatJsonMessage` is only for
          console display).

          2.  When parsing the JSON stream from the `claude` CLI:
              - If a message object represents a `tool_use` of type `Write` (or `Edit`, `MultiEdit`, or any file modification tool claude-code might use - the existing code checks for `Write` specifically for line count summary):
                  - Extract relevant details: `file_path`, a summary of content (e.g., number of lines, or if it's a small change, the change itself), and any description or intent if provided by the tool usage.
                  - Use the global `log` function from `src/logging.ts` to log this information with a specific prefix, e.g., `log('[ClaudeToolCall:TodoWrite]', { filePath, details: ... });`.
              - The `DatabaseLoggerAdapter` (if active in the context where `ClaudeCodeExecutor.execute` is called) will capture this structured log.
          3.  The `DatabaseLoggerAdapter` might need a slight enhancement to
          check if a log message is an object and, if so, store its `details` or
          stringified version in `task_logs.fullContent` while
          `task_logs.message` gets the prefixed summary.
              - In `DatabaseLoggerAdapter`, if `args[0]` is a string like `'[ClaudeToolCall:TodoWrite]'` and `args[1]` is an object, format `message` as `args[0]` and `fullContent` as `JSON.stringify(args[1])`. Otherwise, current behavior.
          This relies on `ClaudeCodeExecutor` being run within a `runWithLogger`
          context using `DatabaseLoggerAdapter`.
        done: false
