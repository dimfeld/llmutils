goal: Implement new metadata fields for `rmplan` YAML files, including `id`,
  `status`, `priority`, timestamps, and fields for tracking issues, pull
  requests, and changed files. This involves updating the plan schema,
  initializing these fields when a plan is created from Markdown, and managing
  their state during plan execution by the agent.
details: >
  The project aims to enhance `rmplan`'s capabilities by adding structured
  metadata to its YAML plan files. This will enable better tracking,
  organization, and automation of tasks.


  **Key changes include:**


  1.  **Schema Update:** The `PlanSchema` (in `src/rmplan/planSchema.ts`) will
  be extended to include the new fields:
      *   `id`: A unique base36 timestamp (epoch 2025-05-01) for the plan file.
      *   `status`: Tracks the plan's lifecycle (`pending`, `in progress`, `done`).
      *   `priority`: Optional field for task prioritization (`unknown`, `low`, `medium`, `high`, `urgent`).
      *   `dependencies`: Optional array of IDs of other task files.
      *   `baseBranch`: Optional branch name this plan builds upon.
      *   `changedFiles`: Optional array of files modified by this task.
      *   `rmfilter`: Optional array of `rmfilter` arguments for detailed planning context.
      *   `issue`: Optional array of URLs to relevant GitHub issues.
      *   `pullRequest`: Optional array of URLs to associated pull requests.
      *   `planGeneratedAt`, `promptsGeneratedAt`, `createdAt`, `updatedAt`: Timestamp fields.

  2.  **Metadata Initialization:**
      *   When a plan is generated from Markdown (via `rmplan extract` or `rmplan generate` without `--no-extract`), the `extractMarkdownToYaml` function in `src/rmplan/actions.ts` will initialize these new fields.
      *   `id` will be generated using a custom base36 timestamp function.
      *   Timestamps (`createdAt`, `updatedAt`, `planGeneratedAt`, `promptsGeneratedAt`) will be set to the current time.
      *   `status` will default to `pending`.
      *   `priority` will default to `unknown`.
      *   `issue` will be populated if the `--issue` flag was used during `rmplan generate`.
      *   `rmfilter` will be populated from `rmfilter:` comments in the issue text and any passthrough `rmfilter` arguments to `rmplan generate`.

  3.  **Runtime Updates by `rmplan agent`:**
      *   `status`: Will transition from `pending` to `in progress` when the agent starts executing the first step of a plan.
      *   `updatedAt`: Will be updated whenever the plan file is modified by the agent (e.g., status change, step completion).
      *   `changedFiles`: After each step is marked done (in `markStepDone`), this field will be updated by comparing the current state of files against the `baseBranch` (or `main`/`master` if `baseBranch` is not set).
      *   `status`: Will transition to `done` in `markStepDone` if all tasks and their steps in the plan are completed.

  **Constraints:**

  *   The existing LLM prompt for plan generation (`src/rmplan/prompt.ts`) and
  the initial Markdown-to-YAML conversion logic performed by the LLM (within
  `convertMarkdownToYaml` in `src/rmplan/cleanup.ts`) **should not** be changed
  to handle these new fields. These fields are metadata to be added *after* the
  LLM produces the core plan structure.

  *   Fields like `dependencies`, `baseBranch`, and `pullRequest` can be left
  empty for now and will be utilized more in future work.

  *   Existing functionality for parsing `rmpr:` comments (in
  `src/rmpr/comment_options.ts`) should be adapted for parsing `rmfilter:`
  comments.

  *   Existing functionality for finding changed files (e.g., `getChangedFiles`
  in `src/rmfilter/additional_docs.ts`) should be reused.


  The implementation will be broken down into tasks focusing on schema updates,
  ID generation, metadata initialization, and runtime state management, with
  tests for each new piece of functionality.
tasks:
  - title: 1. Schema and ID Generation
    description: Update `planSchema.ts` with all new metadata fields and create a
      utility function for generating unique, base36-encoded, time-based IDs.
    files:
      - src/rmplan/planSchema.ts
      - src/common/id_generator.ts
      - src/common/id_generator.test.ts
    include_imports: false
    include_importers: false
    steps:
      - prompt: >
          Modify `src/rmplan/planSchema.ts` to include the new metadata fields.


          The `planSchema` (a Zod schema) should be updated to include the
          following fields:


          - `id`: `z.string().optional()` - This will store a unique base36
          timestamp.

          - `status`: `z.enum(['pending', 'in progress',
          'done']).default('pending').optional()`

          - `priority`: `z.enum(['unknown', 'low', 'medium', 'high',
          'urgent']).default('unknown').optional()`

          - `dependencies`: `z.array(z.string()).default([]).optional()`

          - `baseBranch`: `z.string().optional()`

          - `changedFiles`: `z.array(z.string()).default([]).optional()`

          - `rmfilter`: `z.array(z.string()).default([]).optional()` - Note:
          This field will store rmfilter arguments.

          - `issue`: `z.array(z.string().url()).default([]).optional()`

          - `pullRequest`: `z.array(z.string().url()).default([]).optional()`

          - `planGeneratedAt`, `promptsGeneratedAt`, `createdAt`, `updatedAt`:
          Timestamp fields.


          Ensure these fields are added to the main object definition within the
          Zod schema.

          The existing fields (`goal`, `details`, `tasks`) should remain.

          The `tasks.steps` objects already have a `done` field, which is
          correct.
        done: true
      - prompt: >
          Create a new file `src/common/id_generator.ts`.

          In this file, implement a function `generatePlanId(): string`.


          This function should:

          1. Define a constant `EPOCH` representing the timestamp for
          '2025-05-01T00:00:00.000Z'.
             `const EPOCH = new Date('2025-05-01T00:00:00.000Z').getTime();`
          2. Calculate the current timestamp relative to this epoch: `const
          timestamp = Date.now() - EPOCH;`.

          3. If `timestamp` is negative (which might happen if the system clock
          is set before the epoch), use its absolute value or a small positive
          number (e.g., `Math.abs(timestamp)` or `Math.max(1, timestamp)` to
          ensure it's positive before converting to base36. A simple
          `Math.abs(timestamp)` is fine.

          4. Convert this relative timestamp to a base36 string.

          5. Return the base36 string.


          Example:

          ```typescript

          const EPOCH = new Date('2025-05-01T00:00:00.000Z').getTime();


          export function generatePlanId(): string {
            let timestamp = Date.now() - EPOCH;
            if (timestamp < 0) {
              // This case should ideally not happen with a correct system clock set after the epoch.
              // Using absolute value to prevent issues, and padding for some consistency if it's a small number.
              timestamp = Math.abs(timestamp);
              return timestamp.toString(36).padStart(8, '0');
            }
            return timestamp.toString(36);
          }

          ```
        done: true
      - prompt: >
          Create a new test file `src/common/id_generator.test.ts`.

          Write tests for the `generatePlanId` function in
          `src/common/id_generator.ts`.


          The tests should verify:

          1.  The function returns a string.

          2.  The returned string consists of base36 characters (0-9, a-z).

          3.  IDs generated a few milliseconds apart are different.

          4.  IDs generated sequentially are sortable (i.e., an ID generated
          later should be lexicographically greater than or equal to an ID
          generated earlier, assuming typical base36 string comparison behavior
          for increasing numbers).

          5.  If `Date.now() - EPOCH` is negative, it still produces a valid
          base36 string (e.g., by using the absolute value). You can mock
          `Date.now()` for this test case.


          Use `bun:test` for the test suite.
        done: true
  - title: 2. Metadata Initialization
    description: Modify `extractMarkdownToYaml` in `src/rmplan/actions.ts` to
      populate the new metadata fields. This also involves updating the `rmplan
      generate` command in `src/rmplan/rmplan.ts` to parse `rmfilter:` comments
      from issues and pass necessary information.
    files:
      - src/rmplan/actions.ts
      - src/rmplan/rmplan.ts
      - src/rmpr/comment_options.ts
      - src/common/github/issues.ts
      - src/common/id_generator.ts
      - src/rmfilter/utils.ts
      - src/rmplan/actions.test.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          Modify the `extractMarkdownToYaml` function in
          `src/rmplan/actions.ts`.


          1.  Update the `ExtractMarkdownToYamlOptions` interface to accept:
              ```typescript
              export interface ExtractMarkdownToYamlOptions {
                issueUrls?: string[];
                planRmfilterArgs?: string[];
              }
              ```
          2.  Ensure `generatePlanId` is imported from
          `src/common/id_generator.ts`.

          3.  Inside the `try` block where `validatedPlan` is assigned (after
          `planSchema.safeParse`):
              *   Replace the current `validatedPlan.id = nanoid();` line with `validatedPlan.id = generatePlanId();`.
              *   Set the timestamp fields:
                  ```typescript
                  const now = new Date().toISOString();
                  validatedPlan.createdAt = now;
                  validatedPlan.updatedAt = now;
                  validatedPlan.planGeneratedAt = now;
                  validatedPlan.promptsGeneratedAt = now;
                  ```
              *   The `status` and `priority` fields should be handled by their Zod schema defaults (`pending` and `unknown` respectively).
              *   Populate `validatedPlan.issue`:
                  ```typescript
                  validatedPlan.issue = options.issueUrls && options.issueUrls.length > 0 ? options.issueUrls : [];
                  ```
                  (or rely on schema default `z.array(z.string().url()).default([]).optional()`)
              *   Populate `validatedPlan.rmfilter`:
                  ```typescript
                  validatedPlan.rmfilter = options.planRmfilterArgs && options.planRmfilterArgs.length > 0 ? options.planRmfilterArgs : [];
                  ```
                  (or rely on schema default `z.array(z.string()).default([]).optional()`)
          4.  Update the `orderedPlan` object to include all new fields in the
          following order:
              ```typescript
              const orderedPlan = {
                id: validatedPlan.id,
                status: validatedPlan.status,
                priority: validatedPlan.priority,
                // Optional fields only if they have values or are not empty arrays
                ...(validatedPlan.dependencies?.length && { dependencies: validatedPlan.dependencies }),
                ...(validatedPlan.baseBranch && { baseBranch: validatedPlan.baseBranch }),
                ...(validatedPlan.rmfilter?.length && { rmfilter: validatedPlan.rmfilter }),
                ...(validatedPlan.issue?.length && { issue: validatedPlan.issue }),
                ...(validatedPlan.pullRequest?.length && { pullRequest: validatedPlan.pullRequest }),
                goal: validatedPlan.goal,
                details: validatedPlan.details,
                planGeneratedAt: validatedPlan.planGeneratedAt,
                promptsGeneratedAt: validatedPlan.promptsGeneratedAt,
                createdAt: validatedPlan.createdAt,
                updatedAt: validatedPlan.updatedAt,
                tasks: validatedPlan.tasks,
                ...(validatedPlan.changedFiles?.length && { changedFiles: validatedPlan.changedFiles }),
              };
              ```
              Ensure that optional array fields like `dependencies`, `rmfilter`, `issue`, `pullRequest`, `changedFiles` are only included in `orderedPlan` if they have items. Optional string fields like `baseBranch` are only included if they have a value. `status` and `priority` should always be present due to defaults.
        done: true
      - prompt: >
          Modify the `parseRmprOptions` function in
          `src/rmpr/comment_options.ts`.


          1.  Rename the function to `parseCommandOptionsFromComment`.

          2.  Modify its signature to accept a `prefix: string` argument:
              `export function parseCommandOptionsFromComment(commentBody: string, prefix: string): ParseRmprResult`
          3.  Update the internal logic:
              *   Replace hardcoded checks for `"--rmpr"` and `"rmpr: "` with checks for `"--${prefix}"` and `"${prefix}: "`.
              *   The `isSpecialCommentLine` helper function should also be parameterized or duplicated for `rmfilter`. For now, let's make `isSpecialCommentLine` internal to `parseCommandOptionsFromComment` and make it use the `prefix`.
              *   When parsing arguments from the line, replace `line.replace(/^(?:--rmpr|rmpr:)\s+/, '')` with a dynamic replacement based on the `prefix`.
          4.  The existing logic for parsing arguments like `include-all`,
          `with-imports`, etc., is specific to `rmpr`. For a generic `rmfilter:`
          prefix, we only care about the arguments *after* the prefix.
              So, if `prefix === 'rmfilter'`, the function should:
              *   Extract the string after `"--rmfilter "` or `"rmfilter: "`.
              *   Use `parseCliArgsFromString` (from `src/rmfilter/utils.ts`) on this extracted string.
              *   Return these parsed arguments in the `options.rmfilter` field (or a new generic field if `RmprOptions` is too specific, but for now, reusing `rmfilter` field is fine for simplicity, assuming `parseCommandOptionsFromComment` is only called with `rmpr` or `rmfilter` prefixes).
              *   If `prefix === 'rmpr'`, the existing parsing logic should be maintained.

          Essentially, the goal is to make `parseCommandOptionsFromComment`
          usable for both `--rmpr`/`rmpr:` and `--rmfilter`/`rmfilter:`. When
          `prefix` is `rmfilter`, it should just collect all subsequent tokens
          as an array into `options.rmfilter`.


          Update call sites of the original `parseRmprOptions` to now call
          `parseCommandOptionsFromComment(commentBody, 'rmpr')`.
        done: true
      - prompt: >
          Modify the `generate` command's action in `src/rmplan/rmplan.ts`.


          1.  Import `parseCommandOptionsFromComment` from
          `src/rmpr/comment_options.ts`.

          2.  Import `parsePrOrIssueNumber` from
          `src/common/github/identifiers.ts`.

          3.  After `planText` is determined (from file, editor, or issue):
              *   Initialize `let issueUrlsForExtract: string[] = [];`
              *   Initialize `let planRmfilterArgsForExtract: string[] = [];`
              *   If `options.issue` was used:
                  *   The `issueResult` from `getInstructionsFromGithubIssue` already contains the issue details.
                  *   Construct the issue URL:
                      ```typescript
                      const ghIssue = await parsePrOrIssueNumber(options.issue); // Assuming options.issue is the raw specifier
                      if (ghIssue) {
                          issueUrlsForExtract.push(`https://github.com/${ghIssue.owner}/${ghIssue.repo}/issues/${ghIssue.number}`);
                      }
                      ```
                  *   Parse `rmfilter:` arguments from the issue body:
                      ```typescript
                      if (issueResult.issue.body) {
                          const parsedArgs = parseCommandOptionsFromComment(issueResult.issue.body, 'rmfilter');
                          if (parsedArgs.options?.rmfilter) {
                              planRmfilterArgsForExtract.push(...parsedArgs.options.rmfilter.slice(2)); // .slice(2) to remove the '--'
                          }
                      }
                      ```
                  *   Fetch comments for the issue (this part is missing from `getInstructionsFromGithubIssue` which only returns the plan text and rmprOptions). You might need to call `fetchIssueAndComments` from `src/common/github/issues.ts` if `issueResult` doesn't already contain raw comments. Let's assume `issueResult.comments` (an array of comment objects with a `body` field) is available.
                      ```typescript
                      // Placeholder: Assuming issueResult contains comments. If not, fetch them.
                      // const issueData = await fetchIssueAndComments(ghIssue);
                      // const comments = issueData.comments;
                      // For now, let's assume issueResult.rawComments (an array of strings) exists for simplicity.
                      // This part needs to be robust based on actual data structure from getInstructionsFromGithubIssue.
                      // Let's refine: getInstructionsFromGithubIssue returns `plan` (concatenated selected comments/body)
                      // and `rmprOptions`. We need the raw text of body and *all* comments to parse `rmfilter:` from.
                      // So, inside the `if (options.issue)` block:
                      // const fullIssueData = await fetchIssueAndComments(ghIssue); // Fetch full data
                      // if (fullIssueData.issue.body) {
                      //   const parsedArgs = parseCommandOptionsFromComment(fullIssueData.issue.body, 'rmfilter');
                      //   if (parsedArgs.options?.rmfilter) planRmfilterArgsForExtract.push(...parsedArgs.options.rmfilter.slice(2));
                      // }
                      // for (const comment of fullIssueData.comments) {
                      //   if (comment.body) {
                      //     const parsedArgs = parseCommandOptionsFromComment(comment.body, 'rmfilter');
                      //     if (parsedArgs.options?.rmfilter) planRmfilterArgsForExtract.push(...parsedArgs.options.rmfilter.slice(2));
                      //   }
                      // }
                      ```
                      The `getInstructionsFromGithubIssue` already fetches issue and comments. We need to access the raw bodies.
                      Let's assume `issueResult.issue.body` and `issueResult.allCommentsRawText: string[]` are available.
                      If `issueResult.issue.body` exists, parse `rmfilter:` from it.
                      Iterate through `issueResult.allCommentsRawText`, parse `rmfilter:` from each.
                      (This requires `getInstructionsFromGithubIssue` to be modified or a new function to get raw texts).

                      **Simplified approach for this step:**
                      If `options.issue` is used, `issueResult` is obtained from `getInstructionsFromGithubIssue`.
                      `issueResult.plan` is the combined text. We can parse `rmfilter:` from `issueResult.plan` itself if `getInstructionsFromGithubIssue` concatenates *all* relevant text that might contain `rmfilter:` comments.
                      However, `getInstructionsFromGithubIssue` calls `selectIssueComments` which might filter out comments.
                      It's safer to re-parse from the original source.
                      Let's assume `getInstructionsFromGithubIssue` is modified to return `rawIssueBody: string | null` and `rawComments: Array<{body: string | null}>`.

                      ```typescript
                      // Inside if (options.issue) block in rmplan generate:
                      // (issueResult is already available)
                      // const ghIssue = await parsePrOrIssueNumber(options.issue); // Already done by getInstructionsFromGithubIssue
                      // const fullIssueData = await fetchIssueAndComments(issueResult.issue); // issueResult.issue contains owner, repo, number
                      const fullIssueData = await fetchIssueAndComments({owner: issueResult.issue.owner.login, repo: issueResult.issue.repo.name, number: issueResult.issue.number}); // Assuming issueResult.issue has this structure

                      if (fullIssueData.issue.body) {
                          const parsedArgs = parseCommandOptionsFromComment(fullIssueData.issue.body, 'rmfilter');
                          if (parsedArgs.options?.rmfilter) {
                              planRmfilterArgsForExtract.push(...parsedArgs.options.rmfilter.slice(2)); // Remove '--'
                          }
                      }
                      for (const comment of fullIssueData.comments) {
                          if (comment.body) {
                              const parsedArgs = parseCommandOptionsFromComment(comment.body, 'rmfilter');
                              if (parsedArgs.options?.rmfilter) {
                                 planRmfilterArgsForExtract.push(...parsedArgs.options.rmfilter.slice(2)); // Remove '--'
                              }
                          }
                      }
                      // Construct issue URL
                      issueUrlsForExtract.push(`https://github.com/${fullIssueData.repository.owner.login}/${fullIssueData.repository.name}/issues/${fullIssueData.issue.number}`);
                      ```
                      This seems more robust. `fetchIssueAndComments` needs to be imported.
                      The structure of `fullIssueData` from `fetchIssueAndComments` is `{ issue: Issue, comments: Comment[] }`.
                      So access would be `fullIssueData.issue.body` and `fullIssueData.comments[i].body`.
                      And for URL: `https://github.com/${resolvedPrIdentifier.owner}/${resolvedPrIdentifier.repo}/issues/${resolvedPrIdentifier.number}` (assuming `resolvedPrIdentifier` is the result of `parsePrOrIssueNumber`).
                      The `issueResult` from `getInstructionsFromGithubIssue` contains `issueResult.issue` which has the PR number and can be used to form the URL.
                      Let's use `issueResult.issue` to form the URL and to call `fetchIssueAndComments`.

                      ```typescript
                      // Inside if (options.issue) block in rmplan generate:
                      // issueResult is from getInstructionsFromGithubIssue(options.issue)
                      const issueDetailsForUrl = await parsePrOrIssueNumber(options.issue); // To get owner/repo/number for URL
                      if (issueDetailsForUrl) {
                           issueUrlsForExtract.push(`https://github.com/${issueDetailsForUrl.owner}/${issueDetailsForUrl.repo}/issues/${issueDetailsForUrl.number}`);
                      }

                      // Fetch raw issue body and comments again for rmfilter parsing
                      // (getInstructionsFromGithubIssue might have processed/filtered them)
                      if (issueDetailsForUrl) {
                          const rawData = await fetchIssueAndComments(issueDetailsForUrl);
                          if (rawData.issue.body) {
                              const parsedArgs = parseCommandOptionsFromComment(rawData.issue.body, 'rmfilter');
                              if (parsedArgs.options?.rmfilter) {
                                  planRmfilterArgsForExtract.push(...parsedArgs.options.rmfilter.slice(2));
                              }
                          }
                          for (const comment of rawData.comments) {
                              if (comment.body) {
                                  const parsedArgs = parseCommandOptionsFromComment(comment.body, 'rmfilter');
                                  if (parsedArgs.options?.rmfilter) {
                                     planRmfilterArgsForExtract.push(...parsedArgs.options.rmfilter.slice(2));
                                  }
                              }
                          }
                      }
                      ```
              *   Combine with `userCliRmfilterArgs`: `planRmfilterArgsForExtract.push(...userCliRmfilterArgs);`
              *   When calling `extractMarkdownToYaml` (if `!options.noExtract`), pass the collected `issueUrlsForExtract` and `planRmfilterArgsForExtract`.
                  ```typescript
                  const outputYaml = await extractMarkdownToYaml(input, config, options.quiet ?? false, {
                    issueUrls: issueUrlsForExtract,
                    planRmfilterArgs: planRmfilterArgsForExtract,
                  });
                  ```
        done: true
      - prompt: >
          Add/update tests in `src/rmplan/actions.test.ts` for
          `extractMarkdownToYaml`.


          Verify:

          1.  All new metadata fields (`id`, `status`, `priority`,
          `planGeneratedAt`, `promptsGeneratedAt`, `createdAt`, `updatedAt`,
          `issue`, `rmfilter`, `dependencies`, `baseBranch`, `pullRequest`,
          `changedFiles`) are correctly initialized with expected default values
          or values from options.

          2.  `id` is a valid base36 string.

          3.  Timestamps are valid ISO datetime strings and are recent.

          4.  `status` defaults to "pending".

          5.  `priority` defaults to "unknown".

          6.  `issue` field is populated correctly from `options.issueUrls`.

          7.  `rmfilter` field is populated correctly from
          `options.planRmfilterArgs`.

          8.  `dependencies`, `baseBranch`, `pullRequest`, `changedFiles` are
          initialized as empty arrays or undefined as per schema defaults if not
          provided.

          9.  The output YAML string contains these fields in the specified
          order (id, status, priority first, then other metadata, then goal,
          details, timestamps, tasks, changedFiles).
        done: true
  - title: 3. Runtime Status and Timestamp Updates
    description: Update `rmplan agent` and `markStepDone` to manage `status`,
      `updatedAt`, and `changedFiles` fields during plan execution.
    files:
      - src/rmplan/agent.ts
      - src/rmplan/actions.ts
      - src/rmplan/planSchema.ts
      - src/rmfilter/additional_docs.ts
      - src/rmfilter/utils.ts
      - src/rmplan/agent.test.ts
      - src/rmplan/actions.test.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          Modify the `rmplanAgent` function in `src/rmplan/agent.ts`.


          1.  Inside the `while (stepCount < maxSteps)` loop, after `const
          planData = planResult.data;` and before
          `log(boldMarkdownHeaders(...))`:
              *   Check if `planData.status` is `'pending'`.
              *   If it is, set `planData.status = 'in progress';`.
              *   In either case (status was pending or already in progress), set `planData.updatedAt = new Date().toISOString();`.
              *   Write the updated `planData` back to `currentPlanFile`:
                  ```typescript
                  if (planData.status === 'in progress' || planResult.data.status === 'pending') { // Check if an update was made or if it was pending
                       await Bun.write(currentPlanFile, yaml.stringify(planData));
                  }
                  ```
                  (Ensure `yaml` is imported from the `yaml` package).
        done: true
      - prompt: >
          Modify the `markStepDone` function in `src/rmplan/actions.ts`.


          1.  Import `getChangedFiles` from `src/rmfilter/additional_docs.ts`.

          2.  Import `getGitRoot` from `src/rmfilter/utils.ts`.

          3.  Inside the function, before `const newPlanText =
          yaml.stringify(planData);`:
              *   Set `planData.updatedAt = new Date().toISOString();`.
              *   Determine the `gitRoot` for `getChangedFiles`. If `baseDir` is provided to `markStepDone`, use it; otherwise, call `await getGitRoot()`.
                  ```typescript
                  const effectiveGitRoot = baseDir || await getGitRoot();
                  ```
              *   Call `const changed_files = await getChangedFiles(effectiveGitRoot, planData.baseBranch || undefined);`.
                  (Note: `getChangedFiles` might need its default for `baseBranch` to be `CURRENT_DIFF` or similar if `planData.baseBranch` is undefined. The project plan says "main/master if not set". `getChangedFiles` already has logic for this, using `CURRENT_DIFF` which resolves to `HEAD~` or a default branch).
              *   Update `planData.changedFiles = changed_files;`.
              *   Check if all steps in all tasks are done:
                  ```typescript
                  const allTasksDone = planData.tasks.every(task => task.steps.every(step => step.done));
                  if (allTasksDone) {
                    planData.status = 'done';
                  }
                  ```
        done: false
      - prompt: >
          Create a test file `src/rmplan/agent.test.ts` if it doesn't exist, or
          add tests to it.

          Use `bun:test`. You'll need to mock file system operations
          (`Bun.file`, `Bun.write`) and potentially `yaml.parse/stringify`,
          `findPendingTask`, `prepareNextStep`, and `executor.execute`.


          Test the `rmplanAgent` function for status updates:

          1.  **Test Case: Status transitions from 'pending' to 'in progress'.**
              *   Mock `findPendingTask` to return a task.
              *   Mock `prepareNextStep` to return successfully.
              *   Mock `executor.execute` to complete successfully.
              *   Mock `markStepDone` to indicate the plan is not yet complete.
              *   Setup a temporary plan file with `status: 'pending'`.
              *   Run `rmplanAgent` for 1 step.
              *   Verify that the plan file content now has `status: 'in progress'` and `updatedAt` is a recent timestamp.
          2.  **Test Case: `updatedAt` is updated even if status was already 'in
          progress'.**
              *   Setup a temporary plan file with `status: 'in progress'` and an old `updatedAt` timestamp.
              *   Run `rmplanAgent` for 1 step.
              *   Verify `updatedAt` is updated to a recent timestamp, and status remains `in progress`.

          Helper function for creating temp plan file:

          ```typescript

          import * as fs from 'fs/promises';

          import * as path from 'path';

          import * as os from 'os';

          import yaml from 'yaml';

          import type { PlanSchema } from '../planSchema'; // Adjust path


          async function createTempPlanFile(initialPlan: Partial<PlanSchema>):
          Promise<string> {
            const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'rmplan-agent-test-'));
            const planFilePath = path.join(tempDir, 'test-plan.yml');
            const fullPlan: PlanSchema = {
              id: 'test-id',
              status: 'pending',
              priority: 'unknown',
              goal: 'Test Goal',
              details: 'Test Details',
              createdAt: new Date(Date.now() - 100000).toISOString(), // Older timestamp
              updatedAt: new Date(Date.now() - 100000).toISOString(),
              planGeneratedAt: new Date(Date.now() - 100000).toISOString(),
              promptsGeneratedAt: new Date(Date.now() - 100000).toISOString(),
              tasks: [{
                title: 'Test Task',
                description: 'Test Task Description',
                files: ['file1.ts'],
                steps: [{ prompt: 'Step 1', done: false }],
              }],
              ...initialPlan,
            };
            await fs.writeFile(planFilePath, yaml.stringify(fullPlan));
            return planFilePath;
          }

          // Remember to clean up tempDir in afterEach.

          ```
        done: false
      - prompt: >
          Add/update tests in `src/rmplan/actions.test.ts` for the
          `markStepDone` function.

          Use `bun:test`. You'll need to mock file system operations or use
          temporary files.


          1.  **Test Case: `updatedAt` is updated.**
              *   Create a plan object with an old `updatedAt`.
              *   Call `markStepDone`.
              *   Verify the returned (or written) plan data has a recent `updatedAt`.
          2.  **Test Case: `changedFiles` is updated.**
              *   Mock `getChangedFiles` from `src/rmfilter/additional_docs.ts` to return a specific list of files (e.g., `['fileA.ts', 'fileB.ts']`).
              *   Create a plan object.
              *   Call `markStepDone`.
              *   Verify `planData.changedFiles` in the written YAML matches the mocked list.
              *   Test with `planData.baseBranch` set and unset to ensure `getChangedFiles` is called correctly.
          3.  **Test Case: `status` becomes 'done' when all steps complete.**
              *   Create a plan with one task and one step, initially not done.
              *   Call `markStepDone` to mark that step done.
              *   Verify `planData.status` in the written YAML is 'done'.
          4.  **Test Case: `status` remains 'in progress' if not all steps
          complete.**
              *   Create a plan with one task and two steps, none done.
              *   Call `markStepDone` to mark the first step done.
              *   Verify `planData.status` in the written YAML is still 'in progress' (or 'pending' if it hadn't started, though `markStepDone` is usually called by agent which sets it to 'in progress'). Assume it was 'in progress'.

          Example setup for a plan file for testing `markStepDone`:

          ```typescript

          // Inside a test case

          const tempDir = await fs.mkdtemp(path.join(os.tmpdir(),
          'markstepdone-test-'));

          const planFilePath = path.join(tempDir, 'test-plan.yml');

          const initialPlanData: PlanSchema = { /* ... setup plan data ... */ };

          await fs.writeFile(planFilePath, yaml.stringify(initialPlanData));

          // Call markStepDone(planFilePath, ...)

          const updatedPlanText = await fs.readFile(planFilePath, 'utf-8');

          const updatedPlanData = yaml.parse(updatedPlanText);

          // Assertions on updatedPlanData

          // await fs.rm(tempDir, { recursive: true, force: true }); // Cleanup

          ```

          Remember to mock `getGitRoot` if `baseDir` is not passed to
          `markStepDone`.
        done: false
  - title: 4. Update `parseCommandOptionsFromComment` for `rmfilter` prefix
    description: Refine `parseCommandOptionsFromComment` in
      `src/rmpr/comment_options.ts` to correctly handle the `rmfilter` prefix by
      collecting all subsequent arguments.
    files:
      - src/rmpr/comment_options.ts
      - src/rmpr/comment_options.test.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          Refine the `parseCommandOptionsFromComment` function in
          `src/rmpr/comment_options.ts`.


          The previous prompt aimed to make this function generic. Let's ensure
          the logic for the `rmfilter` prefix is robust.


          Current relevant part of `RmprOptions`:

          ```typescript

          export interface RmprOptions {
            // ... other fields ...
            rmfilter?: string[]; // This field will store arguments for rmfilter
          }

          ```


          Modify `parseCommandOptionsFromComment(commentBody: string, prefix:
          string): ParseRmprResult` as follows:


          1.  The `isSpecialCommentLine` helper (internal or passed) should
          correctly identify lines starting with `"--${prefix}"` or `"${prefix}:
          "`.

          2.  When iterating through `rmprLines` (which are lines matching the
          prefix):
              *   Extract the argument string part by removing the prefix (e.g., `line.replace(new RegExp(`^(?:--${prefix}|${prefix}:)\\s+`), '').trim()`).
              *   If `prefix === 'rmfilter'`:
                  *   Parse the extracted argument string using `parseCliArgsFromString` (from `src/rmfilter/utils.ts`).
                  *   Initialize `options.rmfilter = options.rmfilter || [];`.
                  *   Push `'--'` onto `options.rmfilter` if it's not already the last element (to separate these args from potential previous rmfilter args if `parseCommandOptionsFromComment` is called multiple times and results are merged). Then push the parsed arguments. A simpler approach might be to always add `--` and then the args, and let the caller handle potential duplicate `--` if merging. For now, let's assume each call to `parseCommandOptionsFromComment` for `rmfilter:` lines results in a self-contained set of arguments starting with `--`.
                      ```typescript
                      const argsForThisLine = parseCliArgsFromString(argumentStringPart);
                      if (argsForThisLine.length > 0) {
                          options.rmfilter = options.rmfilter || [];
                          // Ensure a separator if adding to existing rmfilter args from multiple lines/comments
                          if (options.rmfilter.length > 0 && options.rmfilter[options.rmfilter.length -1] !== '--') {
                               // This logic is tricky if we are parsing multiple rmfilter lines within one commentBody.
                               // Let's simplify: each `rmfilter:` line's args are added.
                               // The calling code (e.g. in rmplan.ts) will aggregate all these.
                               // So, for each line:
                               options.rmfilter.push(...parseCliArgsFromString(argumentStringPart));
                          }
                      }
                      ```
                      Let's refine the `rmfilter` option accumulation. The `RmprOptions` interface has `rmfilter?: string[]`. When `parseCommandOptionsFromComment` encounters an `rmfilter:` line, it should parse the arguments from that line and append them to `options.rmfilter`. The `userCliRmfilterArgs` in `rmplan.ts` are separate. The `planRmfilterArgsForExtract` in `rmplan.ts` will be the aggregation of all `rmfilter:` lines from the issue.

                      Corrected logic for `prefix === 'rmfilter'`:
                      ```typescript
                      // Inside the loop over rmprLines
                      const argumentStringPart = line.replace(new RegExp(`^(?:--${prefix}|${prefix}:)\\s+`), '').trim();
                      if (prefix === 'rmfilter') {
                          const parsedArgs = parseCliArgsFromString(argumentStringPart);
                          if (parsedArgs.length > 0) {
                              options.rmfilter = [...(options.rmfilter || []), ...parsedArgs];
                          }
                          // Continue to next line, do not process rmpr-specific flags for rmfilter lines
                          continue;
                      }
                      // ... (existing rmpr parsing logic for when prefix === 'rmpr') ...
                      ```
              *   If `prefix === 'rmpr'`, the existing parsing logic for `include-all`, `with-imports`, `include` should be used. The `rmfilter` flag *within an rmpr line* (e.g. `--rmpr rmfilter --grep foo`) should still populate `options.rmfilter`.

          The key is that if the *line prefix itself* is `rmfilter:`, then all
          subsequent tokens on that line are arguments for `rmfilter`. If the
          line prefix is `rmpr:`, then we parse `rmpr`-specific flags, one of
          which could be `rmfilter` which then consumes the rest of *that rmpr
          line's arguments* for itself.


          Ensure `argsFromRmprOptions` in the same file correctly handles the
          `options.rmfilter` field by appending its contents to the returned
          argument list, perhaps after a `--` separator if not already present
          as the first element of `options.rmfilter`. The current
          `argsFromRmprOptions` already iterates `options.rmfilter` and adds
          them. The `--` separator logic is in `rmplan.ts` when combining with
          `userCliRmfilterArgs`.

          The `parseRmprOptions` (now `parseCommandOptionsFromComment`) in
          `src/rmpr/comment_options.ts` already has logic for `else if (arg ===
          'rmfilter')`. This part should remain for when `prefix === 'rmpr'`.
          The new logic is for when `prefix === 'rmfilter'`.
        done: false
      - prompt: >
          Update the tests in `src/rmpr/comment_options.test.ts` for the renamed
          and modified `parseCommandOptionsFromComment` function.


          1.  Rename test suite and calls from `parseRmprOptions` to
          `parseCommandOptionsFromComment`.

          2.  Add test cases for when `prefix` is `'rmfilter'`:
              *   `parseCommandOptionsFromComment("rmfilter: --grep foo --include bar.ts", "rmfilter")` should result in `options: { rmfilter: ["--grep", "foo", "--include", "bar.ts"] }`.
              *   `parseCommandOptionsFromComment("--rmfilter --flag1 value1 'quoted value2'", "rmfilter")` should result in `options: { rmfilter: ["--flag1", "value1", "quoted value2"] }`.
              *   Test with multiple `rmfilter:` lines in `commentBody`. The `options.rmfilter` array should accumulate arguments from all such lines.
                  Example:
                  ```
                  const commentBody = "Some text\nrmfilter: arg1 arg2\nMore text\n--rmfilter arg3 \"arg 4\"";
                  const result = parseCommandOptionsFromComment(commentBody, "rmfilter");
                  // expect result.options.rmfilter to be ["arg1", "arg2", "arg3", "arg 4"]
                  ```
          3.  Ensure existing tests for `prefix === 'rmpr'` still pass,
          including those that use the `rmfilter` flag *within* an `rmpr` line
          (e.g., `--rmpr include-all rmfilter --grep foo`).
        done: false
