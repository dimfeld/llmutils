goal: Implement a feature in the `rmfilter` tool to automatically save all
  console output (stdout and stderr) to a file when a YAML configuration
  (`--config` or `--preset`) is used. Provide an option (`--no-save-output`) to
  disable this behavior.
details: >
  The tool currently logs information to the console from various parts of the
  codebase (`console.log`, `console.error`, `debugLog`, output from spawned
  processes via `logSpawn` with `stdio: 'inherit'`). We need to capture all this
  output generated by the main `rmfilter` process and write it incrementally to
  a log file.


  The log file path should be derived from the path of the YAML configuration
  file provided via the `--config` or `--preset` arguments. The `.yml` or
  `.yaml` extension should be replaced with `-agent-output.md`.


  A new command-line flag, `--no-save-output`, will be introduced to allow users
  to opt-out of this automatic saving behaviour, even when a YAML config is
  used.


  The implementation will involve:

  1.  Adding the `--no-save-output` flag to the configuration parsing logic.

  2.  Determining if output saving is required based on the presence of
  `--config`/`--preset` and the absence of `--no-save-output`.

  3.  Calculating the target output file path.

  4.  Implementing a mechanism to hook into `process.stdout.write` and
  `process.stderr.write`. This mechanism will write the captured output chunks
  to the designated file using `Bun.file().writer()` for incremental writing,
  while also calling the original `write` methods to preserve console output.

  5.  Ensuring the file sink is properly closed when the process exits.

  6.  Integrating this capture mechanism into the main application flow,
  activating it early after configuration is processed.


  Testing will involve unit tests for the configuration logic, the output path
  calculation, and the stream capturing mechanism (using mocks for file system
  and process streams), as well as potentially integration tests.
tasks:
  - title: 1. Add Configuration Flag and Output Path Logic
    description: >
      Modify the configuration handling to include the new `--no-save-output`
      flag and add logic to determine if output should be saved and calculate
      the target file path based on the loaded YAML configuration file.
    files:
      - src/rmfilter/config.ts
      - src/rmfilter/rmfilter.ts
      - src/rmfilter/utils.ts
    steps:
      - prompt: >
          Modify `src/rmfilter/config.ts` to add a new global command-line
          option:


          1.  Define a `--no-save-output` boolean flag in the `globalOptions`
          constant within the `getCurrentConfig` function. It should not have a
          short alias.

          2.  Update the help message text within `getCurrentConfig` to include
          documentation for the new `--no-save-output` flag, explaining that it
          disables automatic saving of console output when a preset or config
          file is used.

          3.  In the `getCurrentConfig` function, after parsing arguments and
          potentially loading a YAML config file (where `yamlConfigPath` is
          determined), add logic to decide if output saving is required.

          4.  Saving is required if `yamlConfigPath` is set (meaning `--config`
          or `--preset` was used) AND `globalValues['no-save-output']` is false
          or undefined.

          5.  If saving is required, calculate the `agentOutputPath`. This path
          should be derived from `yamlConfigPath` by replacing the `.yml` or
          `.yaml` extension with `-agent-output.md`. Handle both extensions.

          6.  Modify the return value of `getCurrentConfig` to include the
          calculated `agentOutputPath` (which will be a string path if saving is
          required, or null/undefined otherwise).

          7.  Ensure the `ConfigSchema` and related types do not need
          modification for this CLI-only flag.


          Example path calculation:

          - If `yamlConfigPath` is `/path/to/my-preset.yml`, `agentOutputPath`
          should be `/path/to/my-preset-agent-output.md`.

          - If `yamlConfigPath` is `/path/to/config.yaml`, `agentOutputPath`
          should be `/path/to/config-agent-output.md`.
        done: true
      - prompt: >
          Create a test suite for the configuration changes made in the previous
          step.


          1.  Add tests (likely in `src/rmfilter/config.test.ts`, or create it
          if it doesn't exist) to verify the behavior of the `--no-save-output`
          flag and the calculation of `agentOutputPath`.

          2.  Use `parseArgs` or mock `process.argv` and call `getCurrentConfig`
          (potentially mocking file system interactions like `findPresetFile`
          and `Bun.file().text()` if necessary) to test different scenarios:
              *   No `--config` or `--preset` used: `agentOutputPath` should be null/undefined.
              *   `--config` used, `--no-save-output` absent: `agentOutputPath` should be calculated correctly.
              *   `--preset` used, `--no-save-output` absent: `agentOutputPath` should be calculated correctly (mock `findPresetFile`).
              *   `--config` used, `--no-save-output` present: `agentOutputPath` should be null/undefined.
              *   `--preset` used, `--no-save-output` present: `agentOutputPath` should be null/undefined.
              *   Test correct handling of both `.yml` and `.yaml` extensions in the path calculation.
        done: false
  - title: 2. Implement Output Capture Mechanism
    description: >
      Create a reusable function that intercepts `process.stdout.write` and
      `process.stderr.write`, redirecting the output to a specified file
      incrementally while preserving the original console output.
    files:
      - src/rmfilter/output_capture.ts
      - src/rmfilter/output_capture.test.ts
      - src/rmfilter/utils.ts
    steps:
      - prompt: >
          Create a new file `src/rmfilter/output_capture.ts`.


          1.  Define and export an asynchronous function
          `startOutputCapture(outputPath: string): Promise<{ cleanup: () => void
          } | null>`.

          2.  Inside the function:
              *   Log a debug message (using `debugLog` from `../logging`) indicating that output capture is starting for the given `outputPath`.
              *   Use a try-catch block for file operations.
              *   Get a `Bun.file` handle for the `outputPath`.
              *   Create a `FileSink` using `logFile.writer()`.
              *   Store the original `process.stdout.write` and `process.stderr.write` methods in local variables.
              *   Overwrite `process.stdout.write` with a new function:
                  *   This function should accept the same arguments (`chunk`, `encoding`, `callback`).
                  *   Convert the `chunk` to a string if it's a Buffer.
                  *   Write the string chunk to the `logSink` using `logSink.write(chunkStr)`. Handle potential errors during sink write (e.g., log a warning to the *original* stderr).
                  *   Call the original `stdout.write` method using `apply` to pass through the output to the console: `return originalStdoutWrite.apply(process.stdout, [chunk, encoding, callback]);`.
              *   Overwrite `process.stderr.write` similarly, writing to the *same* `logSink` and calling the original `stderr.write`.
              *   Define a `cleanup` function that:
                  *   Restores `process.stdout.write` and `process.stderr.write` to their original versions.
                  *   Calls `logSink.end()` to ensure the file stream is closed.
                  *   Removes the `beforeExit` listener added below (if possible, see Bun documentation for removing specific listeners).
                  *   Logs a debug message indicating cleanup.
              *   Register a listener for the `process.on('beforeExit', ...)` event. This listener should call `logSink.end()`. *Note: This listener might not be strictly necessary if cleanup is always called, but acts as a fallback.* Consider potential race conditions or abrupt exits.
              *   If any error occurs during file handle/sink creation, log an error using `console.error` (as redirection might not be set up yet) and return `null`.
              *   Return an object `{ cleanup }`.
        done: false
      - prompt: >
          Create a new test file `src/rmfilter/output_capture.test.ts`.


          1.  Import necessary functions and mocks (`describe`, `it`, `expect`,
          `jest`, `spyOn` from `bun:test`).

          2.  Import the `startOutputCapture` function.

          3.  Mock `Bun.file` and `Bun.file().writer()` (the FileSink). The mock
          sink should have `write` and `end` methods that can be spied upon.

          4.  Mock `process.stdout.write` and `process.stderr.write`.

          5.  Mock `process.on` and `process.off` (or equivalent for removing
          listeners if available) to track listener registration/removal.

          6.  Mock `debugLog` from `../logging` (or wherever it's defined).


          Write tests for `startOutputCapture`:

          *   **Successful Setup:**
              *   Verify it calls `Bun.file` and `writer` with the correct path.
              *   Verify it overwrites `process.stdout.write` and `process.stderr.write`.
              *   Verify it registers a `beforeExit` listener.
              *   Verify it returns an object with a `cleanup` function.
          *   **Output Redirection:**
              *   Call the overwritten `process.stdout.write("hello")`. Verify the original stdout mock was called with "hello". Verify the mock sink's `write` method was called with "hello".
              *   Call the overwritten `process.stderr.write("error")`. Verify the original stderr mock was called with "error". Verify the mock sink's `write` method was called with "error".
              *   Test with Buffer inputs as well.
          *   **Cleanup Function:**
              *   Call the returned `cleanup()` function.
              *   Verify it restores the original `process.stdout.write` and `process.stderr.write` methods.
              *   Verify it calls the mock sink's `end()` method.
              *   Verify it attempts to remove the `beforeExit` listener (check `process.off` mock).
          *   **Error Handling:**
              *   Test the case where `Bun.file(outputPath).writer()` throws an error. Verify `startOutputCapture` logs an error and returns `null`. Verify `process.stdout/stderr.write` are not overwritten.
          *   **`beforeExit` Handler (Optional but good):**
              *   Simulate the `beforeExit` event (if possible in the test environment, otherwise just check registration). Verify the registered handler calls `sink.end()`.
        done: false
  - title: 3. Integrate Output Capture into Application
    description: >
      Call the `startOutputCapture` function from the main script after
      configuration is loaded and the output path is determined.
    files:
      - src/rmfilter/rmfilter.ts
      - src/rmfilter/config.ts
      - src/rmfilter/output_capture.ts
      - src/rmfilter/utils.ts
    steps:
      - prompt: >
          Modify `src/rmfilter/rmfilter.ts` to integrate the output capturing
          mechanism.


          1.  Import the `startOutputCapture` function from
          `./output_capture.ts`.

          2.  After the call to `getCurrentConfig()`, retrieve the
          `agentOutputPath` from the returned result.

          3.  Check if `agentOutputPath` is a valid string path.

          4.  If it is, call `await startOutputCapture(agentOutputPath)`.

          5.  Store the returned cleanup function (e.g., `const captureCleanup =
          await startOutputCapture(...)`).

          6.  Consider where/if to call `captureCleanup.cleanup()`. For a CLI
          tool that runs and exits, the `beforeExit` handler within
          `startOutputCapture` might be sufficient to close the sink. Explicit
          cleanup might only be needed if the application had a longer lifecycle
          or required stopping capture mid-execution (which is not the case
          here). For now, rely on the `beforeExit` handler. Ensure the
          `startOutputCapture` correctly registers the `beforeExit` handler.

          7.  Ensure this integration happens *before* any significant console
          logging or process spawning (like `callRepomix` or other `logSpawn`
          calls that might use `stdio: 'inherit'`) occurs in the main script
          flow, but *after* configuration is fully parsed.
        done: false
  - title: 4. Final Review and Documentation
    description: >
      Review the changes, ensure error handling is adequate, and update any
      relevant documentation (like a README) about the new feature and flag.
    files:
      - README.md
      - src/rmfilter/config.ts
      - src/rmfilter/output_capture.ts
    steps:
      - prompt: >
          Perform a final review of the code changes related to the output
          saving feature.


          1.  Check `src/rmfilter/output_capture.ts`: Ensure file errors during
          `writer()` creation are caught and handled gracefully (returning null,
          logging an error). Ensure potential errors during `logSink.write()`
          are caught and logged without crashing the application.

          2.  Check `src/rmfilter/config.ts`: Ensure the help message for
          `--no-save-output` is clear and accurate. Ensure the path calculation
          logic correctly handles `.yml` and `.yaml`.

          3.  Check `src/rmfilter/rmfilter.ts`: Ensure `startOutputCapture` is
          called at the appropriate point in the execution flow.

          4.  Update any relevant documentation (e.g., `README.md`) to explain
          the new automatic output saving behavior when using `--config` or
          `--preset`, the file naming convention
          (`<config-name>-agent-output.md`), and how to disable it using
          `--no-save-output`.
        done: false
