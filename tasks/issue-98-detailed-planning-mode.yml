goal: Implement the "Detailed Planning Mode" feature for `dimfeld/llmutils`,
  enabling phase-based project planning. This involves generating a high-level
  markdown plan with phases, parsing it into phase-specific YAML files,
  generating detailed prompts for each phase, and updating the CLI to support
  these new workflows.
details: >-
  The project aims to enhance `rmplan` with a structured, multi-phase planning
  capability. This will allow breaking down large software features into
  incremental, functional deliverables. Each phase will deliver a working
  component, building upon previous validated phases. The system must maintain
  compatibility with existing single-phase workflows.


  Key deliverables:

  1.  **Modified Planning Prompt:** Update the existing planning prompt to
  generate markdown plans with distinct phases, goals, dependencies, and tasks
  (without implementation details).

  2.  **Markdown Parser:** A new component to parse the generated markdown plan
  into structured data representing phases and their contents.

  3.  **Phase-Specific YAML Generation:** Logic to convert the parsed markdown
  into individual YAML files for each phase, adhering to an updated
  `phaseSchema`. This includes generating unique project and phase IDs and
  resolving dependencies.

  4.  **Per-Phase Prompt Generation:** A new prompt and logic to generate
  detailed implementation steps (prompts, file lists, etc.) for each task within
  a phase, using context from the overall plan and completed dependent phases.

  5.  **CLI Commands:**
      *   `rmplan generate`: (Modified) To output the phase-based markdown plan.
      *   `rmplan parse`: (New) To parse the markdown plan into phase YAML files.
      *   `rmplan generate-phase`: (New) To populate a phase's YAML file with detailed implementation steps.
  6.  **Error Handling:** Mechanisms to save incomplete or erroneous outputs for
  manual correction.

  7.  **Documentation:** Updated README explaining the new feature and CLI
  commands.


  The implementation will follow the specifications outlined in the provided
  project plan document.
tasks:
  - title: 1. Define Phase Schema and ID Utilities
    description: Update the existing `planSchema.ts` to define the `phaseSchema` as
      specified in the project plan. Create utility functions for generating
      project and phase IDs.
    files:
      - src/rmplan/planSchema.ts
      - src/rmplan/id_utils.ts
      - src/rmplan/id_utils.test.ts
      - src/common/id_generator.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          Modify `src/rmplan/planSchema.ts`.

          Rename the existing `planSchema` to `phaseSchema`.

          Update this `phaseSchema` to precisely match the structure defined in
          the "4.2 YAML Schema" section of the project plan.

          Ensure all fields, types, and default values are correctly
          represented.

          The `id` field should be `z.string()` (not optional).

          The `tasks.steps` array should default to an empty array and its
          elements should not have `done` defaulting to true.

          The `dependencies` field should be `z.array(z.string()).default([])`
          and be optional.

          The `changedFiles` field should be `z.array(z.string()).default([])`
          and be optional.

          The `rmfilter` field should be `z.array(z.string()).default([])` and
          be optional.

          The `issue` and `pullRequest` fields should be
          `z.array(z.string().url()).default([]).optional()`.

          Add `planGeneratedAt: z.string().datetime().optional()` and
          `promptsGeneratedAt: z.string().datetime().optional()`.

          Ensure `createdAt` and `updatedAt` are also
          `z.string().datetime().optional()`.


          Export `phaseSchema` and its corresponding TypeScript type
          `PhaseSchema`.
        done: false
      - prompt: >
          Create a new file `src/rmplan/id_utils.ts`.

          This file will contain utility functions for generating IDs related to
          phased plans.


          Import `generatePlanId` from `src/common/id_generator.ts`.


          Implement the following functions:


          1.  `generateProjectId(title: string): string`:
              *   This function should take a project title string.
              *   It should slugify the title (lowercase, replace spaces and special characters with hyphens, remove leading/trailing hyphens).
              *   It should then append a unique component generated by `generatePlanId()`.
              *   Example: `my-project-feature-` + `generatePlanId()`.
              *   Ensure the generated ID is relatively short but unique.

          2.  `generatePhaseId(projectId: string, phaseIndex: number): string`:
              *   This function should take a `projectId` and a `phaseIndex` (1-based).
              *   It should return a string in the format `${projectId}-${phaseIndex}`.

          Add necessary imports.
        done: false
      - prompt: >
          Create a new test file `src/rmplan/id_utils.test.ts`.

          Write unit tests for the functions in `src/rmplan/id_utils.ts`.


          For `generateProjectId(title: string)`:

          - Test with a simple title.

          - Test with a title containing spaces and mixed case.

          - Test with a title containing special characters.

          - Test that two calls with the same title but slightly different times
          produce different IDs.

          - Test that the output format is as expected
          (slugified_title-unique_part).


          For `generatePhaseId(projectId: string, phaseIndex: number)`:

          - Test with a sample `projectId` and `phaseIndex`.

          - Ensure the output format is `${projectId}-${phaseIndex}`.


          Use `bun:test` for assertions.
        done: false
  - title: 2. Modify Planning Prompt for Phase-Based Markdown Generation
    description: Update the existing planning prompt in `src/rmplan/prompt.ts` to
      instruct the LLM to generate high-level, phase-based plans in Markdown.
      This Markdown will serve as the input for the `rmplan parse` command.
    files:
      - src/rmplan/prompt.ts
      - src/rmplan/rmplan.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/rmplan/prompt.ts`:


          1.  Modify the existing `planPrompt(plan: string)` function.

          2.  Incorporate the instructions from section "6.1 Modified Planning
          Prompt" of the project plan document. Specifically, add the text:
              ```
              Break this project into phases where each phase delivers working functionality. Each phase should build upon previous phases. Later phases can enhance or extend features from earlier phases.

              For smaller features, a single phase is acceptable. For larger features, consider natural boundaries like:
              - Backend implementation → Frontend implementation → Polish/reporting
              - Core functionality → Enhanced features → Performance optimization
              - Basic CRUD → Advanced queries → UI improvements
              ```
              This text should be inserted before the existing instructions about breaking the project into small, iterative chunks.

          3.  Update the part of the prompt that specifies the output format.
              Currently, it refers to `planMarkdownExampleFormat`. You need to define a new example format string, let's call it `phaseBasedMarkdownExampleFormat`, that reflects the structure described in "4.1 Markdown Plan Structure" of the project plan. This new format string should look like:
              ```markdown
              # Goal
              [Overall project goal]

              ## Details
              [Overall project details and analysis]

              ---

              ### Phase 1: [Phase Title]
              #### Goal
              [Phase-specific goal]
              #### Dependencies
              [None or comma-separated list, e.g., Phase 2, Phase 3]
              #### Details
              [Phase description]
              ##### Task: [Task 1 Title]
              **Description:** [Task 1 description]
              ##### Task: [Task 2 Title]
              **Description:** [Task 2 description]

              ---

              ### Phase 2: [Phase Title]
              ... (similar structure) ...
              ```
              Replace the reference to `planMarkdownExampleFormat` in the main prompt with this new `phaseBasedMarkdownExampleFormat`.

          4.  Ensure the prompt clearly states that tasks within phases should
          *only* include a title and description, and *not* detailed
          implementation steps, file lists, or
          `include_imports`/`include_importers` flags. These will be generated
          in a later stage (`rmplan generate-phase`).

          5.  Retain existing instructions about test-driven development,
          documentation updates, and incremental progress, as these are still
          relevant at a high level.
        done: false
      - prompt: >
          In `src/rmplan/rmplan.ts`:


          Locate the `generate` command action.

          Currently, it calls `planPrompt(planText!)`. Ensure it continues to do
          so, using the modified `planPrompt` from the previous step.

          The output of `rmplan generate` (which is the LLM response to this
          prompt) will be the phase-based markdown.

          No changes to the command's options or primary logic are needed for
          this step, as the prompt modification handles the new output format.

          The user will then manually save this output or pipe it to a file
          (e.g., `feature_plan.md`).
        done: false
  - title: 3. Implement Markdown Parser Logic
    description: Create a new module `src/rmplan/markdown_parser.ts` to parse the
      phase-based markdown generated in the previous task. This parser will
      extract the overall project goal and details, as well as information for
      each phase (title, numeric index, goal, dependencies, details, and tasks).
    files:
      - src/rmplan/markdown_parser.ts
      - src/rmplan/markdown_parser.test.ts
    include_imports: false
    include_importers: false
    steps:
      - prompt: >
          Create `src/rmplan/markdown_parser.ts`.

          Import the `marked` library for basic Markdown tokenization: `import {
          marked } from 'marked';`.


          Define the following interfaces:

          ```typescript

          export interface ParsedTask {
            title: string;
            description: string;
          }


          export interface ParsedPhase {
            title: string;
            numericIndex: number; // Extracted from "Phase X"
            goal: string;
            dependencies: string[]; // Raw dependency strings, e.g., "Phase 1", "Phase 2"
            details: string;
            tasks: ParsedTask[];
          }


          export interface ParsedMarkdownPlan {
            overallGoal: string;
            overallDetails: string;
            phases: ParsedPhase[];
            rmfilter?: string[]; // Placeholder for now, if we decide to parse it from MD
          }

          ```


          Implement the main parsing function:

          `export async function parseMarkdownPlan(markdownContent: string):
          Promise<ParsedMarkdownPlan>`


          Inside `parseMarkdownPlan`:

          1.  Initialize `overallGoal`, `overallDetails` to empty strings, and
          `phases` to an empty array.

          2.  Use `marked.lexer(markdownContent)` to get tokens.

          3.  Iterate through the tokens to populate the `ParsedMarkdownPlan`
          structure:
              *   Look for a top-level heading (depth 1) with text "Goal" for `overallGoal`. Content is subsequent paragraph(s).
              *   Look for a heading (depth 2) with text "Details" for `overallDetails`. Content is subsequent paragraph(s).
              *   Identify phase blocks:
                  *   A phase starts with a heading (depth 3) matching `### Phase X: [Title]`. Extract `X` as `numericIndex` and `[Title]` as `title`.
                  *   Within a phase block, look for:
                      *   `#### Goal`: Subsequent paragraph(s) for phase `goal`.
                      *   `#### Dependencies`: Subsequent paragraph(s) for `dependencies`. Parse comma-separated values. Handle "None" or empty as no dependencies.
                      *   `#### Details`: Subsequent paragraph(s) for phase `details`.
                      *   `##### Task: [Task Title]`: Extract task title. The subsequent paragraph starting with `**Description:**` is the task description.
          4.  **Single-Phase Fallback**: If no `### Phase X:` headers are found
          after parsing overall goal/details:
              *   Assume the entire content (after overall goal/details, if any) describes a single phase.
              *   Create one `ParsedPhase` object:
                  *   `numericIndex: 1`
                  *   `title: "Implementation"` (or derive from overall goal if possible, or use a default)
                  *   `goal`: Use `overallGoal` or a default.
                  *   `dependencies: []`
                  *   `details`: Use `overallDetails` or the remaining markdown content.
                  *   `tasks`: Parse any `##### Task:` sections found in the remaining content. If no tasks, use a default task based on overall goal/details.
          5.  Return the populated `ParsedMarkdownPlan` object.


          Helper function considerations:

          *   A function to extract text from subsequent paragraph tokens until
          a new heading or specific marker.

          *   A function to parse task details.
        done: false
      - prompt: >
          Create `src/rmplan/markdown_parser.test.ts`.

          Write comprehensive unit tests for `parseMarkdownPlan` in
          `src/rmplan/markdown_parser.ts`.


          Test cases should cover:

          1.  **Multi-phase plan:**
              *   Correct extraction of `overallGoal` and `overallDetails`.
              *   Correct extraction of multiple phases with their `title`, `numericIndex`, `goal`, `dependencies` (none, single, multiple), `details`.
              *   Correct extraction of multiple tasks within each phase, with `title` and `description`.
          2.  **Single-phase plan (implicit):**
              *   Markdown input without `### Phase X` headers.
              *   Verify it's parsed as a single phase (index 1, default title, etc.).
              *   Verify overall goal/details are used for the single phase's goal/details if specific phase sections are missing.
              *   Verify task extraction if tasks are present.
              *   Verify default task creation if no tasks are present.
          3.  **Edge Cases:**
              *   Plan with only overall goal/details, no phases defined (should become a single phase).
              *   Phase with no tasks.
              *   Phase with no dependencies.
              *   Phase with dependencies like "None".
              *   Markdown with extra whitespace or slightly varied formatting (within reason).
              *   Empty input string.
              *   Markdown missing overall goal or details sections.

          Use `bun:test` for assertions. Mock `marked` if necessary, or provide
          raw markdown strings as input.

          Focus on the accuracy of the parsed structure (`ParsedMarkdownPlan`).
        done: false
  - title: 4. Implement `rmplan parse` Command
    description: Create the `rmplan parse --input <markdown_file> --output-dir
      <dir>` command. This command will use the markdown parser from Task 3,
      generate project and phase IDs, resolve dependencies, and create
      individual YAML files for each phase.
    files:
      - src/rmplan/rmplan.ts
      - src/rmplan/actions.ts
      - src/rmplan/id_utils.ts
      - src/rmplan/markdown_parser.ts
      - src/rmplan/planSchema.ts
      - src/common/model_factory.ts
      - ai
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/rmplan/rmplan.ts`, add a new command:

          `program.command('parse')`
            `.description('Parse a phase-based markdown plan into YAML files for each phase.')`
            `.requiredOption('-i, --input <markdownFile>', 'Path to the input phase-based markdown plan file.')`
            `.requiredOption('-o, --output-dir <outputDir>', 'Directory to save the generated phase YAML files.')`
            `.option('--project-id <id>', 'Specify a project ID. If not provided, one will be generated.')`
            `.option('--issue <issue_number_or_url>', 'GitHub issue number or URL to associate with the project and use for naming.')`
            `.action(async (options) => { ... });`

          Implement the action handler for the `parse` command.

          It should perform the following:

          1.  Read the input markdown file content.

          2.  Call `parseMarkdownPlan` from `src/rmplan/markdown_parser.ts` to
          get `ParsedMarkdownPlan`.

          3.  Determine the `projectId`:
              *   If `options.projectId` is provided, use it.
              *   Else if `options.issue` is provided:
                  *   Parse the issue using `parsePrOrIssueNumber` from `src/common/github/identifiers.ts`.
                  *   Fetch issue details using `fetchIssueAndComments` from `src/common/github/issues.ts`.
                  *   Construct `projectId` as `issue-${issueData.number}-${slugify(issueData.title)}`. (You'll need a simple slugify function or use one from `id_utils.ts` if `generateProjectId` is suitable).
              *   Else (neither `projectId` nor `issue` provided):
                  *   Use `generateText` with a model like 'google/gemini-2.0-flash' to generate a concise title from `parsedPlan.overallGoal` and `parsedPlan.overallDetails`.
                  *   Use `generateProjectId` from `src/rmplan/id_utils.ts` with this generated title to create the `projectId`.
          4.  Create the output directory: `${options.outputDir}/${projectId}`.
          Ensure it exists.

          5.  Iterate through `parsedPlan.phases`:
              *   For each `ParsedPhase`, create a `PhaseSchema` object.
                  *   `id`: Generate using `generatePhaseId(projectId, phase.numericIndex)`.
                  *   `goal`: `phase.goal`.
                  *   `details`: `phase.details`.
                  *   `tasks`: Map `phase.tasks` to `PhaseSchema` tasks (title, description, empty `files`, empty `steps`, default `include_imports`/`importers`).
                  *   `status`: `'pending'`.
                  *   `priority`: `'unknown'`.
                  *   `dependencies`: Initially store the raw string dependencies (e.g., `["Phase 1", "Phase 2"]`).
                  *   `planGeneratedAt`: Current ISO datetime string.
                  *   `createdAt`: Current ISO datetime string.
                  *   `updatedAt`: Current ISO datetime string.
                  *   `rmfilter`: Copy from `parsedPlan.rmfilter` if available, or from global CLI options if passed to `rmplan generate` initially (this part needs careful thought on how `rmfilter` propagates). For now, assume it might come from `parsedPlan.rmfilter` or leave empty.
                  *   `issue`: If `options.issue` was used, populate with the issue URL.
          6.  After creating all initial `PhaseSchema` objects, resolve
          dependencies:
              *   Create a map of `numericIndex` to `phaseId`.
              *   Iterate through each `PhaseSchema` object again. For its `dependencies` array (which contains raw strings like "Phase 1"), convert each raw string to the corresponding full `phaseId` using the map. E.g., "Phase 1" becomes `${projectId}-1`. Handle cases where a dependency reference is invalid (e.g., "Phase 99" doesn't exist) by logging a warning and omitting it.
          7.  Implement circular dependency detection:
              *   Build a dependency graph.
              *   Check for cycles. If a cycle is detected, log an error and suggest manual correction. Do not write YAML files if a cycle is found, or write them with a warning.
          8.  For each `PhaseSchema` object, serialize it to YAML and write to
          `${options.outputDir}/${projectId}/phase_${phase.numericIndex}.yaml`.
              *   Use `yaml.stringify` from the `yaml` package.
              *   Include the schema line: `# yaml-language-server: $schema=https://raw.githubusercontent.com/dimfeld/llmutils/main/schema/rmplan-plan-schema.json` at the top of each YAML file.
          9.  Log success messages or errors.
        done: false
      - prompt: >
          Create integration tests for the `rmplan parse` command.

          These tests should:

          1.  Set up a temporary directory with a sample `feature_plan.md` file
          (multi-phase).

          2.  Run `rmplan parse --input feature_plan.md --output-dir
          ./parsed_plan`.

          3.  Verify:
              *   The `parsed_plan/<projectId>/` directory is created.
              *   The correct number of `phase_X.yaml` files are generated.
              *   Each YAML file is valid against `phaseSchema`.
              *   Content of a sample phase YAML:
                  *   Correct `id`, `goal`, `details`, `tasks` (with empty steps).
                  *   Correctly resolved `dependencies` (full phase IDs).
                  *   Timestamps are set.
          4.  Test with a single-phase markdown input.

          5.  Test project ID generation:
              *   With `--project-id` option.
              *   With `--issue` option (mock GitHub calls if necessary, or test the naming convention).
              *   Without explicit ID/issue (mock LLM call for title generation or check for a default/fallback naming).
          6.  Test circular dependency detection: create a markdown input with
          circular dependencies and verify an error is logged/thrown.

          7.  Test error handling for malformed markdown input (if
          `parseMarkdownPlan` throws or returns partial data).


          Use `bun:test`. Create temporary files and directories as needed.
        done: false
  - title: 5. Per-Phase Prompt Template and Context Aggregation Logic
    description: Create the LLM prompt template for generating detailed steps within
      a phase. Implement the logic to aggregate all necessary context for this
      prompt, including overall project goals, details of the current phase,
      information from completed dependent phases, and relevant codebase files.
    files:
      - src/rmplan/prompt.ts
      - src/rmplan/actions.ts
      - src/rmplan/planSchema.ts
      - src/rmfilter/rmfilter.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/rmplan/prompt.ts`:


          Define an interface `PhaseGenerationContext`:

          ```typescript

          interface PhaseGenerationContext {
            overallProjectGoal: string;
            overallProjectDetails: string;
            currentPhaseGoal: string;
            currentPhaseDetails: string;
            currentPhaseTasks: Array<{ title: string; description: string }>; // Tasks from the current phase YAML (before step generation)
            previousPhasesInfo: Array<{ id: string; title: string; goal: string; description: string }>; // Info from dependent, completed phases
            changedFilesFromDependencies: string[]; // Concatenated list of changedFiles from completed dependencies
            rmfilterArgsFromPlan: string[]; // rmfilter args from the original plan/request
            // Potentially add baseBranch if needed
          }

          ```


          Create a new prompt function `generatePhaseStepsPrompt(context:
          PhaseGenerationContext): string`.

          This prompt should instruct the LLM to generate detailed
          implementation steps for the tasks in `context.currentPhaseTasks`.

          The prompt structure should be based on "6.2 Per-Phase Generation
          Prompt" from the project plan.

          It should include placeholders for all fields in
          `PhaseGenerationContext`.

          The LLM's output for this prompt is expected to be a YAML snippet
          representing the `tasks` array for the current phase, but this time
          populated with `files`, `include_imports`, `include_importers`, and
          `steps` for each task.

          The prompt should emphasize:

          - Adherence to the `phaseSchema` for the `tasks` array structure.

          - Test-driven development.

          - Generating specific, actionable steps.

          - Correctly identifying `files` relevant to each task.

          - Setting `include_imports` and `include_importers` flags
          appropriately.

          - Referencing `changedFilesFromDependencies` and `previousPhasesInfo`
          to build upon prior work.
        done: false
      - prompt: >
          In `src/rmplan/actions.ts` (or a new `src/rmplan/phase_actions.ts` if
          preferred for organization):


          Implement `async function gatherPhaseGenerationContext(phaseFilePath:
          string, projectPlanDir: string): Promise<PhaseGenerationContext>`


          This function will:

          1.  Load the target phase YAML file (`phaseFilePath`) using
          `yaml.parse` and validate against `phaseSchema`. Let this be
          `currentPhaseData`.

          2.  Determine the overall project plan's goal and details:
              *   Look for `feature_plan.md` in `projectPlanDir`. If found, parse it (using a simplified markdown parser focusing on top-level Goal/Details, or by convention if these are stored elsewhere).
              *   Alternatively, if `feature_plan.md` is not standard, the overall goal/details might need to be reconstructed or inferred. For now, assume `feature_plan.md` exists or these are passed in. (For a simpler first pass, these could be taken from `currentPhaseData.goal` and `currentPhaseData.details` if we assume the first phase's YAML might store them, or they are duplicated. The project plan implies they are separate).
              *   Let's assume for now: try to read `projectPlanDir/../feature_plan.md`. If it exists, parse its `# Goal` and `## Details`. If not, use `currentPhaseData.goal` as `overallProjectGoal` and `currentPhaseData.details` as `overallProjectDetails` as a fallback.
          3.  Initialize `previousPhasesInfo: []` and
          `changedFilesFromDependencies: []`.

          4.  For each `dependencyId` in `currentPhaseData.dependencies`:
              *   Construct the path to the dependency's YAML file (e.g., `${projectPlanDir}/${dependencyId}.yaml`).
              *   Load and parse the dependency's YAML file.
              *   Ensure its `status` is `'done'` (this check will also be in the CLI command, but good to have context here).
              *   Add its `id`, title (from `details` or a new field if we add it), `goal`, and `details` to `previousPhasesInfo`.
              *   Append its `changedFiles` (if any) to `changedFilesFromDependencies`. Deduplicate `changedFilesFromDependencies`.
          5.  Return the populated `PhaseGenerationContext` object, including:
              *   `overallProjectGoal`, `overallProjectDetails`.
              *   `currentPhaseGoal: currentPhaseData.goal`.
              *   `currentPhaseDetails: currentPhaseData.details`.
              *   `currentPhaseTasks: currentPhaseData.tasks.map(t => ({ title: t.title, description: t.description }))`.
              *   `previousPhasesInfo`.
              *   `changedFilesFromDependencies`.
              *   `rmfilterArgsFromPlan: currentPhaseData.rmfilter || []`.

          This function needs robust error handling for file loading and
          parsing.
        done: false
  - title: 6. Implement `rmplan generate-phase` Command
    description: Create the `rmplan generate-phase --phase <phase_yaml_file>`
      command. This command loads a phase YAML, checks its dependencies, gathers
      context (including codebase files via `rmfilter`), invokes an LLM to
      generate detailed steps for tasks, and updates the phase YAML with these
      details.
    files:
      - src/rmplan/rmplan.ts
      - src/rmplan/actions.ts
      - src/rmplan/prompt.ts
      - src/rmplan/planSchema.ts
      - src/rmfilter/rmfilter.ts
      - src/common/model_factory.ts
      - ai
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/rmplan/rmplan.ts`, add a new command:

          `program.command('generate-phase')`
            `.description('Generate detailed steps and prompts for a specific phase.')`
            `.requiredOption('-p, --phase <phaseYamlFile>', 'Path to the phase YAML file.')`
            `.option('--force', 'Override dependency completion check and proceed with generation.')`
            `.option('-m, --model <model_id>', 'Specify the LLM model to use for generating phase details.')`
            `.action(async (options) => { ... });`

          Implement the action handler for `generate-phase`.

          1.  Load `RmplanConfig` using `loadEffectiveConfig`.

          2.  Resolve `options.phaseYamlFile` to an absolute path.

          3.  Load the target phase YAML file (`currentPhaseData: PhaseSchema`).
          Validate its schema.

          4.  **Dependency Checking:**
              *   For each `dependencyId` in `currentPhaseData.dependencies`:
                  *   Construct path: `path.join(path.dirname(options.phaseYamlFile), dependencyId.split('-').pop() + '.yaml')` (e.g. `phase_1.yaml` from `projectid-1`). Or, more robustly, assume phase files are named `phase_X.yaml` where X is the index.
                  *   Load the dependency's YAML.
                  *   If `status` is not `'done'`:
                      *   Log a warning: `Dependency ${dependencyId} is not complete (status: ${status}).`
                      *   If `!options.force`, log an error and exit.
                      *   If `options.force`, log a warning that generation is proceeding despite incomplete dependencies.
          5.  Determine `projectPlanDir` (directory containing all
          `phase_X.yaml` files, e.g., `feature_plan/`). This is
          `path.dirname(options.phaseYamlFile)`.

          6.  Call `gatherPhaseGenerationContext(options.phaseYamlFile,
          projectPlanDir)` to get `phaseGenCtx`.

          7.  **Prepare `rmfilter` arguments for codebase context:**
              *   Start with `rmfilterArgsFromPlan` from `phaseGenCtx`.
              *   Add files listed in `currentPhaseData.tasks[].files` (if any are pre-populated, though typically they won't be at this stage).
              *   These arguments will be used by `runRmfilterProgrammatically`.
          8.  **Invoke `rmfilter` programmatically:**
              *   Use `runRmfilterProgrammatically` (from `src/rmfilter/rmfilter.ts`) with the prepared arguments and `projectPlanDir` (or git root if more appropriate for `rmfilter`).
              *   The output of `rmfilter` is `codebaseContextXml`.
          9.  **Construct LLM Prompt for Step Generation:**
              *   Create the final prompt string by combining `generatePhaseStepsPrompt(phaseGenCtx)` and `codebaseContextXml`. The `codebaseContextXml` should be appended, perhaps within `<codebase_context>` tags.
          10. **Call LLM:**
              *   Use `streamText` (from `ai` SDK) with the constructed prompt.
              *   The model to use is `options.model` or a default from `RmplanConfig` or a hardcoded fallback.
              *   The LLM is expected to return a YAML string snippet representing the `tasks` array (with `files`, `steps`, etc., populated).
          11. **Parse LLM Output:**
              *   Parse the YAML snippet from the LLM. This should be an array of task objects.
              *   If parsing fails or the structure is incorrect, save the raw LLM output to disk (e.g., `phase_X.llm_error.yaml`) and log an error. Exit or allow manual correction.
          12. **Update Phase YAML:**
              *   Merge the LLM-generated task details into `currentPhaseData.tasks`. For each task in `currentPhaseData.tasks` (matched by title or order), update its `files`, `include_imports`, `include_importers`, and `steps` fields from the parsed LLM output.
              *   Set `currentPhaseData.promptsGeneratedAt = new Date().toISOString()`.
              *   Set `currentPhaseData.updatedAt = new Date().toISOString()`.
          13. Write the updated `currentPhaseData` back to
          `options.phaseYamlFile`.

          14. Log success.
        done: false
      - prompt: >
          Create integration tests for the `rmplan generate-phase` command.

          Setup:

          - A temporary project directory.

          - An overall `feature_plan.md` (minimal, just for overall
          goal/details).

          - A `parsed_plan/<project_id>/` directory.

          - `phase_1.yaml` (status: 'done', with some `changedFiles`).

          - `phase_2.yaml` (status: 'pending', depends on phase_1, tasks defined
          but steps are empty).

          - Some dummy source files in the temp project directory that
          `rmfilter` can pick up.


          Test cases:

          1.  **Successful generation:**
              *   Run `rmplan generate-phase --phase parsed_plan/<project_id>/phase_2.yaml`.
              *   Mock the LLM call to return a valid YAML snippet for `phase_2.yaml`'s tasks.
              *   Verify `phase_2.yaml` is updated correctly:
                  *   `tasks[].files`, `tasks[].steps`, etc., are populated.
                  *   `promptsGeneratedAt` and `updatedAt` are set.
          2.  **Dependency check (fail):**
              *   Set `phase_1.yaml` status to `'pending'`.
              *   Run `rmplan generate-phase` for `phase_2.yaml`. Verify it exits with an error or logs a strong warning.
          3.  **Dependency check (force):**
              *   Set `phase_1.yaml` status to `'pending'`.
              *   Run `rmplan generate-phase --force` for `phase_2.yaml`. Verify it proceeds (mock LLM).
          4.  **Context aggregation:**
              *   Within the test, spy on or check the inputs to the LLM prompt generation to ensure:
                  *   Overall goal/details are included.
                  *   Current phase (phase_2) goal/details/tasks are included.
                  *   Previous phase (phase_1) info (goal, description) is included.
                  *   `changedFiles` from phase_1 are included.
                  *   `rmfilter` args from `phase_2.yaml` (if any) are used for codebase context.
          5.  **Error handling (LLM output malformed):**
              *   Mock LLM to return invalid YAML.
              *   Verify an error is logged and raw output is saved.
          Use `bun:test`.
        done: false
  - title: 7. Single-Phase Project Support and Error Handling Refinements
    description: Ensure that single-phase projects (where the markdown plan has no
      explicit `### Phase X` headers) are correctly handled by `rmplan parse`
      and `rmplan generate-phase`. Implement robust error handling across all
      new commands, saving partial or erroneous outputs to disk for manual
      correction as specified in the project plan.
    files:
      - src/rmplan/markdown_parser.ts
      - src/rmplan/rmplan.ts
      - src/rmplan/actions.ts
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/rmplan/markdown_parser.ts`:

          Review the `parseMarkdownPlan` function.

          Ensure the single-phase fallback logic is robust:

          - If no `### Phase X:` headers are found:
              - It correctly creates a single `ParsedPhase` with `numericIndex: 1`.
              - The `title` for this single phase should be sensible, e.g., "Implementation Phase" or derived from the overall project goal.
              - `goal` and `details` for this phase should be populated from `overallGoal` and `overallDetails` if these were parsed. If not, they can be generic placeholders.
              - Tasks should be parsed from the main body of the markdown if `##### Task:` headers are present.
              - If no tasks are found, a default task should be created based on the `overallGoal` (e.g., Task title: "Implement: [overallGoal]").
          Add specific unit tests in `markdown_parser.test.ts` for these
          single-phase scenarios, including cases with and without explicit
          tasks in the markdown.
        done: false
      - prompt: >
          In `src/rmplan/rmplan.ts`:


          For the `parse` command:

          - If `parseMarkdownPlan` returns a plan with a single phase due to the
          fallback, ensure project ID and phase ID (`${projectId}-1`) are
          generated correctly.

          - Ensure the single `phase_1.yaml` file is created.


          For the `generate-phase` command:

          - It should work correctly when pointed to a `phase_1.yaml` from a
          single-phase project. Dependencies will be empty, so dependency checks
          should pass trivially. Context aggregation should still work (overall
          goal/details will be available).


          Error Handling Implementation (as per "7. Error Handling" in project
          plan):


          Modify `rmplan parse` action:

          - If `parseMarkdownPlan` throws an error or returns a structure that's
          problematic (e.g., critical missing fields before YAML generation can
          even start):
              - Log a clear error message.
              - Save the original input markdown file to a path like `${outputDir}/${projectId}/feature_plan.error.md` (if `projectId` is determined) or `${outputDir}/feature_plan.error.md`.
              - Save an error log file (e.g., `parse_error.log`) in the same directory with details of the error.
              - Exit gracefully.
          - If YAML generation for a specific phase fails (e.g., due to data
          issues not caught by schema, though schema should be robust):
              - Save any partially generated YAML for that phase to `phase_X.error.yaml`.
              - Log a warning for that phase and continue with other phases if possible.
          - If circular dependency detection fails:
              - Save all generated (but potentially problematic) phase YAMLs to disk.
              - Log a clear error about the circular dependency, listing the involved phases.
              - Suggest manual correction of the YAML files or the source markdown.

          Modify `rmplan generate-phase` action:

          - If the LLM output for step generation is not valid YAML or doesn't
          match the expected structure for tasks:
              - Log an error.
              - Save the raw LLM output to `${phaseFilePath}.llm_error.txt`.
              - Save the phase YAML file in its current state (before attempting to merge LLM output) or save a partial version if some tasks were processed, to `${phaseFilePath}.partial_error.yaml`.
              - Suggest manual correction.
          - If any other error occurs during context gathering or `rmfilter`
          execution:
              - Log the error clearly.
              - Save any available context or partial output to disk for debugging.
        done: false
      - prompt: >
          Update integration tests for `rmplan parse` and `rmplan
          generate-phase` to cover:

          - End-to-end flow for a single-phase project (generate markdown
          without phase headers -> parse -> generate-phase).

          - Error scenarios:
              - `parse`: Input malformed markdown, verify error output and saved files.
              - `parse`: Input markdown with circular dependencies, verify error output.
              - `generate-phase`: Mock LLM to return malformed YAML, verify error output and saved files.
        done: false
  - title: 8. Documentation Update
    description: Update the `README.md` file to include documentation for the new
      "Detailed Planning Mode" feature, including the new CLI commands,
      workflow, and file structures.
    files:
      - README.md
    include_imports: false
    include_importers: false
    steps:
      - prompt: >
          Update `README.md` to document the new "Detailed Planning Mode"
          feature.


          Add a new major section, possibly titled "Multi-Phase Project
          Planning" or "Detailed Planning Mode".


          This section should cover:

          1.  **Overview**: Briefly explain the purpose of phase-based planning
          (breaking large features, incremental deliverables).

          2.  **Workflow**:
              *   `rmplan generate --input plan.md --output feature_plan.md`: Explain that this (potentially modified) command now generates a high-level markdown plan with phases. Mention the structure (overall goal/details, then phases with goals, dependencies, tasks).
              *   `rmplan parse --input feature_plan.md --output-dir ./my_feature_plan`: Explain this new command, its inputs, and how it creates a directory (e.g., `./my_feature_plan/my_project_id/`) containing `phase_X.yaml` files.
              *   `rmplan generate-phase --phase ./my_feature_plan/my_project_id/phase_1.yaml`: Explain this new command, how it populates a specific phase YAML with detailed steps, and its dependency on completed prior phases.
              *   Mention the iterative nature: implement phase, review, merge, then `generate-phase` for the next one.
          3.  **File Structure**:
              *   Show the example structure:
                  ```
                  project-directory/
                  ├── plan.md                  # Original input for `rmplan generate`
                  ├── feature_plan.md          # Generated phase-based markdown plan
                  └── my_feature_plan/         # Directory specified in `rmplan parse --output-dir`
                      └── my_project_id/       # Directory named after the auto-generated/specified project ID
                          ├── phase_1.yaml
                          ├── phase_2.yaml
                          └── ...
                  ```
          4.  **Markdown Plan Structure (`feature_plan.md`)**:
              *   Provide a snippet of the expected markdown structure (from "4.1 Markdown Plan Structure" of the project plan).
              *   Highlight key elements: overall goal/details, `### Phase X: [Title]`, `#### Goal`, `#### Dependencies`, `#### Details`, `##### Task: [Title]`.
          5.  **Phase YAML Structure (`phase_X.yaml`)**:
              *   Briefly mention it follows the `phaseSchema` (which is the updated `planSchema`).
              *   Point out that `tasks[].steps` are initially empty and populated by `rmplan generate-phase`.
          6.  **Project Naming**: Explain how `projectId` is derived (from issue
          or autogenerated).

          7.  **Single-Phase Projects**: Briefly explain that if
          `feature_plan.md` has no `### Phase X` headers, `rmplan parse` treats
          it as a single phase.

          8.  **Error Handling**: Mention that in case of errors, partial
          outputs or raw LLM responses might be saved to disk for manual
          inspection and correction.


          Update the existing `rmplan generate` command description if its
          behavior for generating the initial plan has significantly changed
          (e.g., if it now always tries to output phases).


          Ensure the new commands are added to any command reference or quick
          start sections.

          Maintain a clear and concise style.
        done: false
  - title: 9. Refine Project ID Generation for `rmplan parse`
    description: Refine the project ID generation logic within the `rmplan parse`
      command. If a GitHub issue is provided, the project ID should be
      `issue-ISSUENUMBER-SLUGIFIEDTITLE`. Otherwise, if no explicit project ID
      is given, use Gemini Flash (or a similar fast model) to generate a concise
      title from the overall project goal/details, then slugify this title and
      append a unique ID component.
    files:
      - src/rmplan/rmplan.ts
      - src/rmplan/id_utils.ts
      - src/common/github/issues.ts
      - src/common/github/identifiers.ts
      - src/common/model_factory.ts
      - ai
    include_imports: true
    include_importers: false
    steps:
      - prompt: >
          In `src/rmplan/id_utils.ts`:

          Modify `generateProjectId(title: string)`:

          - Ensure the slugification part is robust (handles various special
          characters, consecutive hyphens, leading/trailing hyphens).

          - The unique component should be short, e.g., 4-6 characters from
          `generatePlanId()`.

          - The final ID should not be excessively long. Consider truncating the
          slugified title if it's very long before appending the unique part.


          Add a new function `slugify(text: string): string`:

          - Converts text to lowercase.

          - Replaces spaces and non-alphanumeric characters (except hyphens)
          with hyphens.

          - Replaces multiple consecutive hyphens with a single hyphen.

          - Removes leading and trailing hyphens.

          - Export this function.
        done: false
      - prompt: >
          In `src/rmplan/rmplan.ts`, within the `parse` command's action
          handler:


          Refine the `projectId` determination logic:

          1.  If `options.projectId` is provided, use it directly. Sanitize it
          to ensure it's a valid directory name component (e.g., using the new
          `slugify` function from `id_utils.ts`).

          2.  Else if `options.issue` is provided:
              *   Use `parsePrOrIssueNumber` to get owner, repo, number.
              *   Use `fetchIssueAndComments` to get the issue title.
              *   `const slugTitle = slugify(issueData.title);`
              *   `projectId = \`issue-${issueData.number}-${slugTitle}\`;`
              *   Truncate `slugTitle` if it's too long to keep `projectId` manageable.
          3.  Else (neither `options.projectId` nor `options.issue` provided):
              *   Extract `overallGoal` and `overallDetails` from `parsedPlan`.
              *   Construct a prompt for an LLM (e.g., 'google/gemini-2.0-flash') like:
                  ```
                  Based on the following project goal and details, suggest a very short, concise, slug-style title (2-5 words, lowercase, hyphenated).
                  Goal: ${parsedPlan.overallGoal}
                  Details: ${parsedPlan.overallDetails}
                  Respond with ONLY the slug-style title.
                  ```
              *   Call `generateText` from the `ai` SDK.
              *   `const llmGeneratedTitle = slugify(llmResponse.text.trim());`
              *   `projectId = generateProjectId(llmGeneratedTitle);` (The `generateProjectId` function will handle further slugification and adding the unique part).
              *   Add error handling for the LLM call; if it fails, fall back to a generic `projectId` like `generateProjectId('unnamed-project')`.
          4.  After `projectId` is determined, log it: `log(chalk.blue('Using
          Project ID:'), projectId);`

          5.  The output directory for phase YAMLs will be
          `${options.outputDir}/${projectId}`. Ensure this directory is created.
        done: false
      - prompt: >
          Update tests in `src/rmplan/id_utils.test.ts` for the modified
          `generateProjectId` and new `slugify` function.

          - `slugify`: Test various inputs (spaces, mixed case, special chars,
          leading/trailing hyphens, multiple hyphens).

          - `generateProjectId`: Test with pre-slugified and non-slugified
          titles, ensure unique component is appended and overall length
          constraints are reasonable.


          Update integration tests for `rmplan parse`:

          - Specifically test the project ID generation path when `--issue` is
          used (mock GitHub calls to provide a title, verify the
          `issue-NUMBER-slug` format).

          - Test the path where an LLM generates the title (mock the
          `generateText` call, verify a `slug-UNIQUEID` format).
        done: false
id: 1453cny
status: in_progress
priority: unknown
rmfilter:
  - src/rmplan
  - --with-imports
issue:
  - https://api.github.com/repos/dimfeld/llmutils/issues/98
planGeneratedAt: 2025-05-29T02:13:21.502Z
promptsGeneratedAt: 2025-05-29T02:13:21.502Z
createdAt: 2025-05-29T02:13:21.502Z
updatedAt: 2025-05-29T02:13:54.225Z
