This project is designed to implement the feature: Detailed Planning Mode

# Phase-Based Project Planning Tool - Complete Specification

## 1. Overview

The project planning tool generates phase-based plans for software development, breaking large features into incremental, functional deliverables. Each phase delivers a working component (e.g., backend API first, then frontend UI, then reporting). The system supports multi-phase projects while maintaining compatibility with single-phase workflows for simpler features.

### Key Process Flow
1. Generate a high-level plan in markdown with phase divisions
2. Parse the markdown plan into phase-specific YAML files
3. Generate detailed prompts for each phase as it's being implemented
4. Execute phases in dependency order with review between phases

### Core Benefits
- Large features get reviewed incrementally
- Later phases build on validated foundations
- Context accumulates naturally through `changedFiles`
- Flexibility in phase design per feature
- Maintains existing single-phase workflow for simple tasks

## 2. Requirements

### 2.1 Functional Requirements

- **Generate High-Level Plan**: Create a markdown file with phases, each containing goal, dependencies, details, and tasks (without implementation prompts)
- **Parse Plan into YAML Files**: Convert markdown into separate YAML files for each phase, following defined schema
- **Generate Per-Phase Prompts**: Populate each phase's YAML with detailed steps and prompts when that phase is ready for implementation
- **Dependency Management**: Ensure phases execute in order by validating dependencies and warning if incomplete
- **Context Propagation**: Pass `changedFiles` and high-level information from completed phases to subsequent phases
- **Error Handling**: Save incomplete or erroneous outputs to disk for manual correction
- **Single-Phase Support**: Treat projects without phase divisions as Phase 1

### 2.2 Non-Functional Requirements

- **Usability**: Simple CLI interface for all operations
- **Maintainability**: Modular design with clear separation of planning, parsing, and prompt generation
- **Extensibility**: Allow future enhancements (e.g., phase splitting/merging, complex dependency graphs)
- **Flexibility**: Open-ended phase granularity determined by LLM based on project context

## 3. Architecture

### 3.1 Components

1. **Planning Prompt**: Generates high-level markdown plan with phases
2. **Parsing Script**: Converts markdown plan into YAML files for each phase
3. **Per-Phase Generation Prompt**: Populates each phase's YAML with detailed steps and prompts
4. **Validation and Error Handling**: Ensures data integrity and manages errors
5. **CLI Interface**: Commands to execute each step of the process

### 3.2 Data Flow

1. **Input**: Project plan from GitHub issues, local MD file, or other source
2. **Generate Plan**: Use `rmplan generate` to produce phase-based markdown plan
3. **Parse Plan**: Use `rmplan parse` to convert markdown into phase YAML files
4. **Generate Phase Prompts**: Use `rmplan generate-phase` to populate phase with detailed steps
5. **Implement and Review**: Execute phase with AI coding agent, review, merge
6. **Repeat**: Continue with next phase after dependencies complete

### 3.3 File Structure

```
project-directory/
├── plan.md                  # Original input
├── feature_plan.md          # Generated phase plan
└── feature_plan/           # Directory named after project
    ├── phase_1.yaml        # ${id}-1
    ├── phase_2.yaml        # ${id}-2
    └── phase_3.yaml        # ${id}-3
```

**Project Naming**:
- From issues: `issue-ISSUENUMBER-TITLE`
- Otherwise: autogenerated title using Gemini Flash

## 4. Data Handling

### 4.1 Markdown Plan Structure

```markdown
# Goal
[Overall project goal]

## Details
[Overall project details and analysis]

---

### Phase 1: [Phase Title]
#### Goal
[Phase-specific goal]
#### Dependencies
[None or comma-separated list, e.g., Phase 2, Phase 3]
#### Details
[Phase description]
##### Task: [Task 1 Title]
**Description:** [Task 1 description]
##### Task: [Task 2 Title]
**Description:** [Task 2 description]

---

### Phase 2: [Phase Title]
#### Goal
[Phase-specific goal]
#### Dependencies
Phase 1
#### Details
[Phase description]
##### Task: [Task Title]
**Description:** [Task description]
```

**Key Structure Rules**:
- Phase headers use `### Phase X: [Title]` format
- Dependencies listed as comma-separated phase references
- Tasks include title and description only (no implementation details)
- Single-phase projects may omit phase headers (treated as Phase 1)

### 4.2 YAML Schema

Each phase file follows the existing `planSchema` structure:

```typescript
const phaseSchema = z.object({
  id: z.string(),                // Format: ${projectId}-${phaseIndex}
  goal: z.string(),
  details: z.string(),
  tasks: z.array(
    z.object({
      title: z.string(),
      description: z.string(),
      files: z.array(z.string()).default([]),
      include_imports: z.boolean().default(false),
      include_importers: z.boolean().default(false),
      examples: z.array(z.string()).optional(),
      steps: z.array(
        z.object({
          prompt: z.string(),
          examples: z.array(z.string()).optional(),
          done: z.boolean().default(false),
        })
      ).default([]), // Empty until phase prompt generation
    })
  ),
  status: z.enum(['pending', 'in_progress', 'done']).default('pending'),
  priority: z.enum(['unknown', 'low', 'medium', 'high', 'urgent']).default('unknown').optional(),
  dependencies: z.array(z.string()).default([]), // Phase IDs this depends on
  baseBranch: z.string().optional(),
  changedFiles: z.array(z.string()).default([]),
  rmfilter: z.array(z.string()).default([]),      // From original request
  issue: z.array(z.string().url()).default([]).optional(),
  pullRequest: z.array(z.string().url()).default([]).optional(),
  planGeneratedAt: z.string().datetime().optional(),
  promptsGeneratedAt: z.string().datetime().optional(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
});
```

**ID Generation**:
- During parsing: Extract numeric index from "Phase X" (e.g., "1", "2")
- After parsing: Generate project ID, then create phase IDs as `${projectId}-${numericIndex}`
- Dependencies converted from phase references to full IDs

## 5. CLI Commands

### 5.1 `rmplan generate`

**Purpose**: Generate high-level phase-based plan  
**Command**: `rmplan generate --input plan.md --output feature_plan.md`  
**Input**: Original project plan with `rmfilter` context  
**Output**: Markdown file with phases, goals, dependencies, and tasks  

### 5.2 `rmplan parse`

**Purpose**: Parse markdown plan into YAML files  
**Command**: `rmplan parse --input feature_plan.md --output-dir feature_plan/`  
**Process**:
1. Parse markdown structure
2. Extract phase information and numeric indices
3. Generate project ID
4. Create phase IDs as `${projectId}-${numericIndex}`
5. Convert dependency references to full IDs
6. Create separate YAML file for each phase
7. Validate no circular dependencies

### 5.3 `rmplan generate-phase`

**Purpose**: Generate detailed steps and prompts for a specific phase  
**Command**: `rmplan generate-phase --phase feature_plan/phase_1.yaml`  
**Process**:
1. Load target phase YAML
2. Check all dependencies have `status: done` (warn if not, exit unless `--force`)
3. Gather context:
   - Overall project goal and details
   - Target phase goal, description, and tasks
   - Dependency phases' goals and descriptions
   - `changedFiles` from completed dependencies
   - Original codebase files via `rmfilter`
4. Generate prompts and populate `files`, `include_imports`, `include_importers`, and `steps`
5. Update phase YAML with generated content

**Options**:
- `--force`: Override dependency completion check

## 6. Prompt Templates

### 6.1 Modified Planning Prompt

Key additions to existing prompt:
```
Break this project into phases where each phase delivers working functionality. Each phase should build upon previous phases. Later phases can enhance or extend features from earlier phases.

For smaller features, a single phase is acceptable. For larger features, consider natural boundaries like:
- Backend implementation → Frontend implementation → Polish/reporting
- Core functionality → Enhanced features → Performance optimization
- Basic CRUD → Advanced queries → UI improvements

When generating the final output, use the following format:
[Existing format structure with ### Phase X: headers]
```

**Retained elements**:
- Test-driven development emphasis
- Documentation update requirements
- Early testing and incremental progress

**Removed elements** (moved to per-phase):
- Specific implementation details
- Mock/dependency injection guidance
- File-level prompt details

### 6.2 Per-Phase Generation Prompt

Inputs provided:
```
Overall Project Goal: [From original plan]
Overall Project Details: [From original plan]

Previous Phases:
- Phase 1: [Goal and description]
- Phase 2: [Goal and description]

Current Phase to Implement:
Goal: [Current phase goal]
Description: [Current phase details]
Tasks:
1. [Task title]: [Task description]
2. [Task title]: [Task description]

Context from Previous Phases:
- Files created/modified: [List from changedFiles]

[Original codebase context files]
```

Instructions include all implementation details from original prompt:
- File selection and include_imports/include_importers flags
- Mock avoidance and dependency injection
- Specific prompt generation for each step

## 7. Error Handling

### 7.1 Error Types and Responses

1. **Parsing Errors**:
   - Malformed markdown structure → Save output to disk with error log
   - Missing required fields → Save partial YAML with warnings

2. **Dependency Errors**:
   - Circular dependencies → Detect during parsing, save output for correction
   - Non-existent phase references → Convert to empty dependency, log warning
   - Incomplete dependencies → Error during `generate-phase`, override with `--force`

3. **Generation Errors**:
   - LLM output doesn't match expected format → Save raw output to disk
   - Incomplete prompt generation → Save partial YAML

### 7.2 Recovery Strategy

All errors save outputs to disk for manual correction, allowing users to:
- Edit markdown and re-parse
- Manually adjust YAML files
- Fix dependency issues
- Resume from any point in the process

## 8. Testing Strategy

### 8.1 Unit Tests

**Markdown Parsing**:
- Phase header recognition (with and without titles)
- Dependency parsing (none, single, multiple)
- Task extraction with descriptions
- Single-phase fallback behavior
- ID generation (numeric extraction → full ID creation)

**YAML Generation**:
- Schema compliance validation
- Dependency ID conversion
- Empty steps array initialization

### 8.2 Integration Tests

**End-to-End Workflows**:
- Single-phase project: generate → parse → generate-phase
- Multi-phase project with linear dependencies
- Multi-phase project with complex dependencies
- Error recovery workflows

**Phase Generation**:
- Context aggregation from multiple sources
- Dependency validation (complete/incomplete)
- `--force` flag behavior
- File list deduplication

### 8.3 Edge Cases

- Empty phases (no tasks)
- Phases with 10+ dependencies
- Very long phase descriptions
- Special characters in phase titles
- Concurrent phase execution (future feature)

## 9. Implementation Notes

### 9.1 Planning Phase
- LLM determines phase boundaries based on project complexity
- No hard limits on number of phases
- Emphasize functional deliverables per phase
- Avoid prescriptive phase templates

### 9.2 Parsing Phase
- Robust markdown parsing with fallbacks
- Clear error messages for manual correction
- Preserve all content from original markdown

### 9.3 Prompt Generation Phase
- Reference prior phases' context without repetition
- Clear delineation of current phase scope
- Maintain consistency with existing prompt style
- Include only necessary context files

### 9.4 Future Enhancements
- Phase splitting/merging after initial generation
- Parallel phase execution for non-dependent phases
- Progress tracking and reporting
- Integration with CI/CD pipelines

## 10. Documentation

### README.md Structure
1. **Quick Start**: Basic commands for common workflows
2. **Prerequisites**: Node.js version, dependencies
3. **Installation**: npm/yarn setup instructions
4. **Command Reference**: Detailed CLI documentation
5. **File Structure**: Expected inputs/outputs
6. **Examples**: Sample projects with multiple phases
7. **Troubleshooting**: Common issues and solutions
8. **Architecture**: High-level system design

### User Guides
- "Converting Single-Phase to Multi-Phase Projects"
- "Best Practices for Phase Dependencies"
- "Manual Intervention and Error Recovery"
- "Integrating with AI Coding Agents"