// Command handler for 'rmplan split'
// Uses LLM to intelligently split a large plan into smaller, phase-based plans with dependencies

import * as path from 'path';
import chalk from 'chalk';
import yaml from 'yaml';
import { error, log } from '../../logging.js';
import { createModel } from '../../common/model_factory.js';
import { runStreamingPrompt } from '../llm_utils/run_and_apply.js';
import { loadEffectiveConfig } from '../configLoader.js';
import { readPlanFile, resolvePlanFile, writePlanFile, readAllPlans } from '../plans.js';
import { generateSplitPlanPrompt } from '../prompt.js';
import { multiPhasePlanSchema, type PlanSchema } from '../planSchema.js';
import {
  findYamlStart,
  saveMultiPhaseYaml,
  type ExtractMarkdownToYamlOptions,
} from '../process_markdown.js';
import { fixYaml } from '../fix_yaml.js';
import type { Command } from 'commander';
import { resolveTasksDir } from '../configSchema.js';
import { generateNumericPlanId } from '../id_utils.js';
import { generatePlanFilename } from '../utils/filename.js';
import { generateText } from 'ai';
import { checkbox } from '@inquirer/prompts';

// --- Manual split helpers ---

/**
 * Parse a task specifier string like "1-3,5" into zero-based indices.
 * Supports ranges, comma-separated values, and whitespace. Uses 1-based indexing in the specifier.
 */
export function parseTaskSpecifier(spec: string, taskCount: number): number[] {
  if (!spec || typeof spec !== 'string') throw new Error('Empty task specifier');
  const parts = spec
    .split(',')
    .map((s) => s.trim())
    .filter(Boolean);
  const indices = new Set<number>();
  for (const part of parts) {
    const m = part.match(/^(\d+)(?:\s*-\s*(\d+))?$/);
    if (!m) throw new Error(`Invalid task specifier segment: '${part}'`);
    const start1 = parseInt(m[1], 10);
    const end1 = m[2] ? parseInt(m[2], 10) : start1;
    if (start1 <= 0 || end1 <= 0) throw new Error('Task indices must be positive');
    const start = Math.min(start1, end1) - 1;
    const end = Math.max(start1, end1) - 1;
    if (start >= taskCount) throw new Error(`Task index ${start1} out of range`);
    for (let i = start; i <= end && i < taskCount; i++) indices.add(i);
  }
  if (indices.size === 0) throw new Error('No tasks selected');
  return Array.from(indices).sort((a, b) => a - b);
}

/**
 * Build child plan title and details from selected tasks. If multiple tasks are provided,
 * details are combined as markdown sections and the title is generated by an LLM.
 */
async function buildChildTitleAndDetails(
  parentTitle: string | undefined,
  selectedTasks: NonNullable<PlanSchema['tasks']>,
  config: any
): Promise<{ title: string; details: string }> {
  if (selectedTasks.length === 1) {
    const t = selectedTasks[0];
    return { title: t.title, details: t.description };
  }

  // Multiple tasks: combine details and call LLM for a concise title
  const details = selectedTasks.map((t) => `## ${t.title}\n\n${t.description}`).join('\n\n');

  let title = '';
  try {
    const model = await createModel('google/gemini-2.0-flash', config);
    const prompt = `Create a concise, one-line plan title capturing the common theme of these tasks.\nParent: ${
      parentTitle || 'Untitled'
    }\n\nTasks:\n${selectedTasks
      .map((t, i) => `${i + 1}. ${t.title}: ${t.description.slice(0, 200)}`)
      .join('\n')}\n\nRespond with only the title.`;
    const res = await generateText({ model, prompt, temperature: 0.2, maxTokens: 60 });
    title = res.text.trim().split('\n')[0] || '';
  } catch (err) {
    // Fallback title
    title = parentTitle ? `${parentTitle} - Split` : 'Split Tasks';
  }

  return { title, details };
}

/**
 * Perform the core manual split: create a child plan with selected tasks' descriptions as details,
 * update parent by removing those tasks, add dependency, set epic if applicable, and write both files.
 * Returns the paths of the written files.
 */
export async function manualSplitPlan(
  parent: PlanSchema & { filename: string },
  selectedIndices: number[],
  config: any
): Promise<{ parentPath: string; childPath: string; childId: number }> {
  if (!parent.id || typeof parent.id !== 'number') {
    throw new Error('Parent plan must have a numeric id');
  }
  if (!Array.isArray(parent.tasks) || parent.tasks.length === 0) {
    throw new Error('Parent plan has no tasks to split');
  }
  if (!selectedIndices || selectedIndices.length === 0) {
    throw new Error('No tasks selected for split');
  }

  // Validate indices
  const unique = Array.from(new Set(selectedIndices)).sort((a, b) => a - b);
  for (const idx of unique) {
    if (idx < 0 || idx >= parent.tasks.length) {
      throw new Error(`Task index out of range: ${idx}`);
    }
  }

  const tasksDir = await resolveTasksDir(config);
  // Preload all plans for ID generation stability
  await readAllPlans(tasksDir);
  const childId = await generateNumericPlanId(tasksDir);

  // Extract selected tasks and build title/details
  const selectedTasks = unique.map((i) => parent.tasks[i]);
  const { title: childTitle, details: childDetails } = await buildChildTitleAndDetails(
    parent.title,
    selectedTasks,
    config
  );

  // Build child plan
  const childPlan: PlanSchema = {
    id: childId,
    title: childTitle,
    goal: parent.goal ?? '',
    details: childDetails,
    parent: parent.id,
    status: 'pending',
    tasks: [],
    tags: parent.tags ? [...parent.tags] : [],
  };

  const filename = generatePlanFilename(childId, childTitle || 'split');
  const childPath = path.join(tasksDir, filename);

  // Update parent: remove selected tasks and add dependency
  const remainingTasks = parent.tasks.filter((_, idx) => !unique.includes(idx));
  parent.tasks = remainingTasks;
  parent.dependencies = Array.from(new Set([...(parent.dependencies || []), childId])).sort(
    (a, b) => a - b
  );
  if (parent.tasks.length === 0) parent.epic = true;

  // Write both files
  await writePlanFile(parent.filename, parent);
  await writePlanFile(childPath, childPlan);

  log(
    chalk.green(
      `âœ“ Split ${unique.length} task(s) into child plan ${childId} and updated parent ${parent.id}`
    )
  );

  return { parentPath: parent.filename, childPath, childId };
}

export async function handleSplitCommand(planArg: string, options: any, command: Command) {
  const globalOpts = command.parent!.opts();

  // Validate mutually exclusive modes
  const hasTasksFlag = options && Object.prototype.hasOwnProperty.call(options, 'tasks');
  const modeFlags = [
    options?.auto ? 'auto' : null,
    hasTasksFlag ? 'tasks' : null,
    options?.select ? 'select' : null,
  ].filter(Boolean) as string[];

  if (modeFlags.length === 0) {
    throw new Error(
      'No mode specified. Choose one of: --auto (LLM-based), --tasks <specifier> (manual), or --select (interactive).'
    );
  }

  if (modeFlags.length > 1) {
    throw new Error(
      'Options --auto, --tasks, and --select are mutually exclusive. Choose only one.'
    );
  }

  // Step 1: Resolve the input plan file path
  const resolvedPlanFile = await resolvePlanFile(planArg, globalOpts.config);

  // Step 2: Read and validate the plan file
  let validatedPlan: PlanSchema;
  try {
    validatedPlan = await readPlanFile(resolvedPlanFile);
  } catch (err) {
    throw new Error(`Failed to read or validate plan file '${resolvedPlanFile}': ${err as Error}`);
  }

  if (options.auto) {
    // Existing LLM-based behavior
    log(chalk.blue('ðŸ“„ Plan loaded successfully:'));
    log(`  Title: ${validatedPlan.title || 'No title'}`);
    log(`  Goal: ${validatedPlan.goal}`);
    if (validatedPlan.tasks) {
      log(`  Tasks: ${validatedPlan.tasks.length}`);
    }

    // Load configuration and generate the prompt
    const splitConfig = await loadEffectiveConfig(globalOpts.config);
    const prompt = generateSplitPlanPrompt(validatedPlan);

    // Call the LLM to reorganize the plan
    log(chalk.blue('\nðŸ¤– Analyzing plan structure and identifying logical phases...'));
    const modelSpec = splitConfig.models?.stepGeneration || 'google/gemini-2.0-flash';
    const model = await createModel(modelSpec, splitConfig);

    let llmResponse: string;
    try {
      const llmResult = await runStreamingPrompt({
        model,
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.2,
      });
      llmResponse = llmResult.text;
    } catch (err) {
      error(`Failed to call LLM for plan splitting: ${err as Error}`);
      throw new Error('Check your model configuration and API credentials.');
    }

    // Extract and parse the YAML from the LLM response
    log(chalk.blue('\nðŸ“ Processing LLM-generated phase structure...'));
    let parsedMultiPhase: any;
    try {
      const yamlContent = findYamlStart(llmResponse);
      const splitConfigLocal = splitConfig; // keep type narrowing stable
      parsedMultiPhase = await fixYaml(yamlContent, 5, splitConfigLocal);
    } catch (err) {
      error(`Failed to parse multi-phase plan from LLM response: ${err as Error}`);

      // Save raw response for debugging
      const debugFile = 'rmplan-split-raw-response.yml';
      await Bun.write(debugFile, llmResponse);
      throw new Error(`\nRaw LLM response saved to ${debugFile} for debugging.`);
    }

    // Validate the multi-phase plan structure
    const validationResult = multiPhasePlanSchema.safeParse(parsedMultiPhase);

    if (!validationResult.success) {
      error(
        'Multi-phase plan validation failed. The LLM output does not match expected structure:'
      );
      validationResult.error.issues.forEach((issue) => {
        error(`  - ${issue.path.join('.')}: ${issue.message}`);
      });

      // Save invalid YAML for debugging
      const debugFile = 'rmplan-split-invalid.yml';
      await Bun.write(debugFile, yaml.stringify(parsedMultiPhase));
      throw new Error(`\nInvalid YAML saved to ${debugFile} for debugging.`);
    }

    // Process the validated multi-phase plan
    const multiPhasePlan = validationResult.data;
    log(chalk.green('\nâœ“ Successfully reorganized plan into phases:'));
    log(`  Total phases: ${multiPhasePlan.phases.length}`);
    multiPhasePlan.phases.forEach((phase, index) => {
      log(`  Phase ${index + 1}: ${phase.title || 'Untitled'} (${phase.tasks.length} tasks)`);
    });

    // Save the multi-phase plan using saveMultiPhaseYaml
    const outputDir = path.join(
      path.dirname(resolvedPlanFile),
      path.basename(resolvedPlanFile, path.extname(resolvedPlanFile))
    );

    const extractOptions: ExtractMarkdownToYamlOptions = {
      output: outputDir,
      projectId: validatedPlan.id,
      issueUrls: validatedPlan.issue,
    };

    const quiet = false;
    const message = await saveMultiPhaseYaml(multiPhasePlan, extractOptions, splitConfig, quiet);
    log(message);
    return;
  }

  // Manual modes
  if (hasTasksFlag) {
    const config = await loadEffectiveConfig(globalOpts.config);
    const indices = parseTaskSpecifier(options.tasks, validatedPlan.tasks?.length || 0);
    // Use validatedPlan with filename context from resolvedPlanFile
    const parentWithPath = { ...validatedPlan, filename: resolvedPlanFile } as PlanSchema & {
      filename: string;
    };
    await manualSplitPlan(parentWithPath, indices, config);
    return;
  }

  if (options.select) {
    const config = await loadEffectiveConfig(globalOpts.config);

    if (!validatedPlan.tasks || validatedPlan.tasks.length === 0) {
      throw new Error('Parent plan has no tasks to select');
    }

    // Build checkbox choices from tasks
    const choices = validatedPlan.tasks.map((t, idx) => ({
      name: `#${idx + 1} ${t.title}`,
      value: idx,
      checked: false,
      // Include a short preview of the description for context
      description: (t.description || '').split('\n').slice(0, 6).join('\n'),
    }));

    let selected: number[] = [];
    try {
      selected = await checkbox({
        message: `Select tasks to split from: ${validatedPlan.title || 'Untitled Plan'}`,
        required: false,
        pageSize: Math.min(10, choices.length + 2),
        shortcuts: { all: 'a' },
        choices,
      });
    } catch (err) {
      // User likely canceled the prompt
      log(chalk.yellow('Selection canceled. No tasks were split.'));
      return;
    }

    if (!selected || selected.length === 0) {
      log(chalk.yellow('No tasks selected. Nothing to do.'));
      return;
    }

    const parentWithPath = { ...validatedPlan, filename: resolvedPlanFile } as PlanSchema & {
      filename: string;
    };
    await manualSplitPlan(parentWithPath, selected, config);
    return;
  }
}
