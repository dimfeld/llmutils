import type { Octokit } from 'octokit';
import type { WebhookEvent } from './types';
import { error, log } from '../logging';

export class ResponseHandler {
  constructor(private octokit: Octokit) {}

  async postComment(event: WebhookEvent, content: string): Promise<void> {
    const { repository } = event;
    const owner = repository.owner.login;
    const repo = repository.name;

    try {
      if (event.issue) {
        // Post to issue
        await this.octokit.rest.issues.createComment({
          owner,
          repo,
          issue_number: event.issue.number,
          body: this.formatComment(content),
        });
        log(`Posted comment to issue #${event.issue.number}`);
      } else if (event.pull_request) {
        // Post to PR
        await this.octokit.rest.issues.createComment({
          owner,
          repo,
          issue_number: event.pull_request.number,
          body: this.formatComment(content),
        });
        log(`Posted comment to PR #${event.pull_request.number}`);
      }
    } catch (e) {
      error('Failed to post comment:', e);
      throw e;
    }
  }

  async postErrorComment(event: WebhookEvent, errorMessage: string): Promise<void> {
    const content = `‚ùå **Error**\n\n${errorMessage}`;
    await this.postComment(event, content);
  }

  async postInProgressComment(event: WebhookEvent, command: string): Promise<number | null> {
    const content = `üîÑ **Processing command:** \`${command}\`\n\nI'll update this comment with the results...`;

    const { repository } = event;
    const owner = repository.owner.login;
    const repo = repository.name;

    try {
      let response;
      if (event.issue) {
        response = await this.octokit.rest.issues.createComment({
          owner,
          repo,
          issue_number: event.issue.number,
          body: content,
        });
      } else if (event.pull_request) {
        response = await this.octokit.rest.issues.createComment({
          owner,
          repo,
          issue_number: event.pull_request.number,
          body: content,
        });
      } else {
        return null;
      }

      return response.data.id;
    } catch (e) {
      error('Failed to post in-progress comment:', e);
      return null;
    }
  }

  async updateComment(event: WebhookEvent, commentId: number, content: string): Promise<void> {
    const { repository } = event;
    const owner = repository.owner.login;
    const repo = repository.name;

    try {
      await this.octokit.rest.issues.updateComment({
        owner,
        repo,
        comment_id: commentId,
        body: this.formatComment(content),
      });
      log(`Updated comment ${commentId}`);
    } catch (e) {
      error('Failed to update comment:', e);
      throw e;
    }
  }

  private formatComment(content: string): string {
    // Add a footer to identify comments from our bot
    return `${content}\n\n---\n<sub>Generated by llmutils bot</sub>`;
  }

  formatExecutionResult(output: string, success: boolean): string {
    const icon = success ? '‚úÖ' : '‚ùå';
    const status = success ? 'Success' : 'Failed';

    return `${icon} **Execution ${status}**\n\n\`\`\`\n${output}\n\`\`\``;
  }

  formatCodeBlock(code: string, language = ''): string {
    return `\`\`\`${language}\n${code}\n\`\`\``;
  }
}
