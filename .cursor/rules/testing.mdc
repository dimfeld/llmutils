---
description: Testing Strategies
globs: *.test.ts
type: rules
---

- Tests use Bun test.
- **Prefer real filesystem operations**: Use `fs.mkdtemp()` for temporary directories instead of mocking filesystem calls
- **Hybrid mocking approach**:
  - Consider mocking complicated external dependencies (logging, process spawning) for interaction verification, but
    mock as little as possible.
  - Use real implementations for core functionality (filesystem operations) for integration confidence
- **Real filesystem tests catch issues mocks miss**: Permission problems, path resolution bugs, cleanup behavior
- Tests should be useful; if a test needs to mock almost all of the functionality, then it should probably not be written.
- Never manually create mocks by just replacing and restoring functions yourself.
- Prefer to use real code to test things, and if you need to emulate a filesystem or Git repository you can set up a temporary directory and clean it up after the test.
- **Mock return shapes must match production types exactly**: If production code returns a `StreamingProcess` (or any structured type), the mock must return that same shape — not a flattened version. When production code has type-guard fallbacks that accept both old and new shapes, wrong-shaped mocks can silently pass while hiding real bugs. Fix the mocks to match the real type and remove dead fallback paths instead.
- **Validate boundary inputs even for internal protocols**: Always test empty, missing, or malformed inputs at protocol boundaries — even between trusted internal components. For example, an empty array being silently treated as success can mask real bugs. Deny or error on invalid inputs rather than letting them fall through to a default "approved" path.


Bun's module mocking does not work properly. If you need to mock a module, use the ModuleMocker class from src/testing.ts instead. For example:

```
const moduleMocker = new ModuleMocker()

afterEach(() => {
  moduleMocker.clear()
})

When a test mocks a module, it should do it this way:

test('a test', async () => {
  await moduleMocker.mock('./services/token.ts', () => ({
    getBucketToken: mock(() => {
      throw new Error('Unexpected error')
    })
  }))
});
```

Or for a single mock defined across the entire test file, use `afterAll(() => moduleMocker.clear())` to clear the mocks.

### Database Tests

- Use `openDatabase(':memory:')` from `src/tim/db/database.ts` for isolated in-memory databases — each test gets a fresh schema via auto-migration
- Close the database in `afterEach` with `db.close(false)` — the `false` argument avoids throwing on pending transactions
- For tests that exercise code calling the singleton `getDatabase()`, use `closeDatabaseForTesting()` in cleanup
