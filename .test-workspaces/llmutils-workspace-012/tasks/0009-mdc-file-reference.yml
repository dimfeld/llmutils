goal: Add the ability for an `.mdc` file to reference other files using an
  `include` field in its frontmatter, prepending the content of these included
  files to the MDC file's main content within the final prompt output.
details: >
  Currently, `.mdc` files (Markdown Domain Configuration) can contain
  frontmatter (parsed using `gray-matter`) and main content. These files are
  used to inject context (like documentation or coding rules) into the LLM
  prompt generated by `rmfilter`.


  This feature introduces a new frontmatter field: `include`.

  - If an `.mdc` file's frontmatter contains an `include` field, its value
  should be interpreted as a path or a list of paths relative to the location of
  the `.mdc` file itself.

  - The content of each valid, accessible file specified in `include` should be
  read.

  - This included content should be prepended to the main content of the `.mdc`
  file before it's placed inside the `<document>` or `<rule>` tags in the final
  output.

  - Path validation (`validatePath`) must be used to prevent accessing files
  outside the project directory.

  - Errors during file reading (e.g., file not found) should be handled
  gracefully (log a warning, skip the file) without stopping the entire process.


  **Key Files Involved:**

  - `src/rmfilter/mdc.ts`: Defines the `MdcFile` interface and parsing logic.
  Will host the new include processing helper.

  - `src/rmfilter/mdc.test.ts`: Tests for MDC parsing and the new helper.

  - `src/rmfilter/additional_docs.ts`: Integrates the include processing into
  the generation of `<documents>` and `<rules>` tags.

  - `src/rmfilter/additional_docs.test.ts`: Tests the integration and final
  output format.

  - `src/rmfilter/utils.ts`: Provides the `validatePath` utility (used, not
  modified).
tasks:
  - title: Update Data Structure and Parsing Tests
    description: Define the new `include` field in the `MdcFile` interface and add
      tests to ensure the existing parser correctly extracts this field.
    files:
      - src/rmfilter/mdc.ts
      - src/rmfilter/mdc.test.ts
    steps:
      - prompt: >
          Modify the `MdcFile` interface in `src/rmfilter/mdc.ts`.


          In the `data` object definition within the `MdcFile` interface, add a
          new optional field named `include`. This field should accept either a
          single string or an array of strings.


          ```

          *Current Interface Snippet:*

          ```typescript

          export interface MdcFile {
            // ... other fields
            data: {
              description?: string;
              globs?: string | string[];
              grep?: string | string[];
              type?: 'docs' | 'rules' | string; // Allow 'docs', 'rules', or other custom types
              name?: string;
              // Allow other potential metadata fields
              [key: string]: any;
            };
          }

          ```


          *Expected Change:* Add `include?: string | string[];` to the `data`
          definition.

          ```
        done: false
      - prompt: >
          Add tests to `src/rmfilter/mdc.test.ts` within the
          `describe('parseMdcFile', ...)` block to verify that the
          `parseMdcFile` function correctly parses the `include` field from the
          frontmatter of an MDC file.


          Use the existing test setup with temporary files (`tempDir`).


          **Test Cases:**


          1.  **Test Case: `include` with a single string value**
              *   Create a temporary MDC file (e.g., `include_single.mdc`) with frontmatter containing `include: "path/to/file.txt"`.
              *   Add some body content.
              *   Call `parseMdcFile` on this file.
              *   Assert that the returned `MdcFile` object is not null.
              *   Assert that `result.data.include` is equal to `"path/to/file.txt"`.
              *   Assert that the `result.content` is correct.

          2.  **Test Case: `include` with an array of string values**
              *   Create a temporary MDC file (e.g., `include_array.mdc`) with frontmatter containing `include: ["path1.js", "dir/path2.ts"]`.
              *   Add some body content.
              *   Call `parseMdcFile`.
              *   Assert that the returned `MdcFile` object is not null.
              *   Assert that `result.data.include` is an array equal to `["path1.js", "dir/path2.ts"]`.
              *   Assert that the `result.content` is correct.

          3.  **Test Case: File without `include` field**
              *   Use an existing test or create a new one for an MDC file *without* the `include` field.
              *   Call `parseMdcFile`.
              *   Assert that the returned `MdcFile` object is not null.
              *   Assert that `result.data.include` is `undefined`.

          Remember that `gray-matter` handles the actual YAML parsing, so these
          tests primarily confirm that the field is correctly passed through
          into our `MdcFile` structure. Ensure proper async/await usage.
        done: false
  - title: Implement Include Processing Logic
    description: Create a helper function that takes an `MdcFile`, resolves its
      `include` paths relative to the MDC file's location, reads the content of
      included files securely, and returns the combined content (included
      content prepended to original content).
    files:
      - src/rmfilter/mdc.ts
      - src/rmfilter/mdc.test.ts
      - src/rmfilter/utils.ts
    steps:
      - prompt: >
          In `src/rmfilter/mdc.ts`, implement a new asynchronous function
          `processMdcIncludes`.


          **Function Signature:**

          ```typescript

          async function processMdcIncludes(mdcFile: MdcFile): Promise<string>

          ```


          **Function Logic:**


          1.  Check if `mdcFile.data.include` exists and has value(s). If not,
          return `mdcFile.content` directly.

          2.  Use the `normalizeArrayInput` helper function (already present in
          `src/rmfilter/mdc.ts`) to convert `mdcFile.data.include` into a
          consistently formatted array of non-empty strings (`includedPaths`).

          3.  If `includedPaths` is empty after normalization, return
          `mdcFile.content`.

          4.  Get the directory path of the `mdcFile` itself using
          `path.dirname(mdcFile.filePath)`. Let's call this `mdcDir`.

          5.  Initialize an empty array `includedContents` to store the content
          of successfully read files.

          6.  Iterate through each `relativePath` in `includedPaths`:
              a.  Use a `try...catch` block to handle potential errors during path validation and file reading for this specific path.
              b.  Inside the `try` block:
                  i.  Call `validatePath(mdcDir, relativePath)` from `src/rmfilter/utils.ts` to get the absolute, validated path (`absoluteIncludePath`). This function will throw an error if the path tries to escape `mdcDir` or is otherwise invalid based on its logic relative to `mdcDir`.
                  ii. Read the content of the file at `absoluteIncludePath` using `await Bun.file(absoluteIncludePath).text()`.
                  iii. Add a small header comment (e.g., `/* Included from: ${relativePath} */\n`) followed by the file content to the `includedContents` array.
              c.  Inside the `catch (error: any)` block:
                  i.  Log a warning message to the console (e.g., `console.warn(\`[MDC Include] Skipping include "${relativePath}" from ${mdcFile.filePath}: ${error.message}\`)`).
                  ii. Continue to the next iteration (do not add anything to `includedContents` for this failed path).
          7.  After the loop, join the elements of `includedContents` with a
          newline (`\n\n`) to form a single `prependedContent` string.

          8.  Return the final combined content:
          `${prependedContent}\n\n${mdcFile.content}`. Ensure there are
          appropriate newlines separating the included content block from the
          original content. If `prependedContent` is empty, just return
          `mdcFile.content`.


          **Imports:** Make sure to import `path`, `validatePath` from
          `./utils.ts`, and potentially `debugLog` if needed (though
          `console.warn` is specified for errors). Also import
          `normalizeArrayInput`.
        done: false
      - prompt: >
          Add a new `describe` block to `src/rmfilter/mdc.test.ts` for the
          `processMdcIncludes` function. Write unit tests for this function.


          **Test Setup:**

          - Use the existing `beforeEach/afterEach` to manage a temporary
          directory (`tempDir`).

          - You will need to create dummy `MdcFile` objects for input and create
          the corresponding physical files (both the MDC file and the files it
          includes) within the `tempDir`.

          - Mock `console.warn` using `vi.spyOn(console,
          'warn').mockImplementation(() => {});` to suppress console noise
          during tests and allow asserting calls. Restore the mock in
          `afterEach`.

          - Import `processMdcIncludes` and `validatePath`. You might need
          `path`.


          **Test Cases:**


          1.  **Test Case: Single valid include**
              *   Create `main.mdc` with `include: "include1.txt"` and content "Main content.".
              *   Create `include1.txt` with content "Include 1 content.".
              *   Create the `MdcFile` object for `main.mdc`.
              *   Call `processMdcIncludes` with the `MdcFile` object.
              *   Assert the returned string is `/* Included from: include1.txt */\nInclude 1 content.\n\nMain content.`.
              *   Assert `console.warn` was *not* called.

          2.  **Test Case: Multiple valid includes**
              *   Create `main.mdc` with `include: ["inc1.js", "subdir/inc2.ts"]` and content "Main.".
              *   Create `inc1.js` with content "Include 1".
              *   Create `subdir/inc2.ts` (create the subdir first) with content "Include 2".
              *   Call `processMdcIncludes`.
              *   Assert the returned string matches the expected combined content with headers for both included files, preserving order.
              *   Assert `console.warn` was *not* called.

          3.  **Test Case: Include file not found**
              *   Create `main.mdc` with `include: "missing.txt"` and content "Main content.".
              *   *Do not* create `missing.txt`.
              *   Call `processMdcIncludes`.
              *   Assert the returned string is *only* "Main content.".
              *   Assert `console.warn` *was* called with a message indicating the failure for "missing.txt".

          4.  **Test Case: Mix of valid and invalid includes**
              *   Create `main.mdc` with `include: ["valid.txt", "missing.txt"]` and content "Main.".
              *   Create `valid.txt` with content "Valid.".
              *   Call `processMdcIncludes`.
              *   Assert the returned string contains the content from `valid.txt` (with header) but not `missing.txt`, prepended to "Main.".
              *   Assert `console.warn` *was* called once for "missing.txt".

          5.  **Test Case: Include path traversal attempt**
              *   Create `main.mdc` with `include: "../outside.txt"` and content "Main.".
              *   (Optional: Create `../outside.txt` relative to `tempDir`'s parent to ensure it exists but is outside).
              *   Call `processMdcIncludes`.
              *   Assert the returned string is *only* "Main.".
              *   Assert `console.warn` *was* called with a message indicating a security error or validation failure for "../outside.txt". (This relies on `validatePath` throwing, which the `catch` block should handle).

          6.  **Test Case: No `include` field**
              *   Create `main.mdc` with *no* `include` field and content "Main.".
              *   Call `processMdcIncludes`.
              *   Assert the returned string is "Main.".
              *   Assert `console.warn` was *not* called.

          7.  **Test Case: Empty `include` array/string**
              *   Create `main.mdc` with `include: []` (or `include: ""`, or `include: " "`) and content "Main.".
              *   Call `processMdcIncludes`.
              *   Assert the returned string is "Main.".
              *   Assert `console.warn` was *not* called.

          Ensure tests use `await` correctly and handle file system operations
          within the test directory.
        done: false
  - title: Integrate Include Processing into Document Generation
    description: Modify `gatherDocsInternal` to use the `processMdcIncludes` helper
      function, ensuring that the content embedded in the final `<documents>`
      and `<rules>` tags includes the prepended content from the `include`
      field. Update tests accordingly.
    files:
      - src/rmfilter/additional_docs.ts
      - src/rmfilter/additional_docs.test.ts
      - src/rmfilter/mdc.ts
    steps:
      - prompt: >
          Modify the `gatherDocsInternal` function in
          `src/rmfilter/additional_docs.ts`.


          **Goal:** Before adding the content of an `MdcFile` (whether it's
          classified as a doc or a rule) to the `allDocumentsData` or
          `allRulesData` arrays, process it using the `processMdcIncludes`
          helper function.


          **Steps:**


          1.  Import `processMdcIncludes` from `./mdc.ts`.

          2.  Locate the loop where `docFiles` are processed (iterating over
          `filteredMdcFiles` and checking `isDoc(mdcFile)`). Inside this loop,
          *before* the `allDocumentsData.push(...)` call:
              a.  Call `const processedContent = await processMdcIncludes(mdcFile);`.
              b.  Replace `mdcFile.content.trim()` with `processedContent.trim()` in the `allDocumentsData.push` call. Ensure you only push if `processedContent.trim()` is not empty.
          3.  Locate the loop where `ruleFiles` are processed (likely the `else`
          block or a separate loop iterating over `filteredMdcFiles` where
          `!isDoc(mdcFile)`). Inside this loop, *before* the
          `allRulesData.push(...)` call:
              a.  Call `const processedContent = await processMdcIncludes(mdcFile);`.
              b.  Replace `mdcFile.content.trim()` with `processedContent.trim()` in the `allRulesData.push` call. Ensure you only push if `processedContent.trim()` is not empty.

          **Note:** The existing logic already trims the content and checks if
          it's non-empty before pushing. Maintain this behavior, but operate on
          the potentially modified `processedContent`. Ensure `async/await` is
          used correctly as `processMdcIncludes` is asynchronous.
        done: false
      - prompt: >
          Update the tests in `src/rmfilter/additional_docs.test.ts` to account
          for the new `include` functionality.


          **Goal:** Verify that `gatherDocsInternal` correctly incorporates
          content from included files into the final `<documents>` and `<rules>`
          tags.


          **Test Setup Modifications:**

          - You will need to enhance the mocking setup. The existing mock for
          `Bun.file` needs to handle the *new* file paths that will be read due
          to the `include` field. Add the included files' paths and content to
          the `mockFiles` dictionary in `beforeEach`.

          - You might need to mock `validatePath` if you want to explicitly test
          security violations, or ensure your `mockFiles` structure allows
          testing valid relative paths from the mock MDC files. Simpler is often
          better: just add the included files to `mockFiles` assuming
          `validatePath` works (as it has its own tests).

          - Add mock MDC file objects (`MdcFile`) that *include* the
          `data.include` field in your test cases.


          **New/Modified Test Cases:**


          1.  **Test Case: MDC Doc with Includes**
              *   Define a mock `MdcFile` (e.g., `mockMdcDocWithInclude`) with `type: 'docs'`, `data: { include: "included_doc.txt" }`, and some `content`.
              *   Add `/project/root/.cursor/rules/included_doc.txt` to `mockFiles` with specific content.
              *   Call `gatherDocsInternal` with this mock MDC file.
              *   Assert that the resulting `docsTag` contains a `<document>` tag where the `CDATA` section includes the content from `included_doc.txt` (with the header comment if you added one) prepended to the original `content` of `mockMdcDocWithInclude`.

          2.  **Test Case: MDC Rule with Includes**
              *   Define a mock `MdcFile` (e.g., `mockMdcRuleWithInclude`) with `type: 'rules'`, `data: { include: ["common_rule.txt", "specific_rule.js"] }`, and some `content`.
              *   Add the paths for `common_rule.txt` and `specific_rule.js` (relative to the mock MDC rule file path) to `mockFiles` with distinct content.
              *   Call `gatherDocsInternal` with this mock file.
              *   Assert that the `rulesTag` contains a `<rule>` tag where the `CDATA` section includes the content from both included files (with headers, preserving order) prepended to the original `content`.

          3.  **Test Case: Includes with Missing Files**
              *   Define a mock `MdcFile` with an `include` pointing to a file *not* in `mockFiles`.
              *   Mock `console.warn`.
              *   Call `gatherDocsInternal`.
              *   Assert that the resulting tag contains *only* the original content (or nothing if the original content was empty).
              *   Assert that `console.warn` was called.

          4.  **Test Case: Combining Manual and MDC Includes**
              *   Include both manual `--docs` (using `glob` mock) and mock MDC files with `include` fields in the same call to `gatherDocsInternal`.
              *   Verify that both manual content and the *processed* MDC content (with includes prepended) appear correctly in the final tags.

          5.  **Test Case: Empty Original Content with Includes**
              *   Define a mock `MdcFile` with `include: "some_content.txt"` but `content: ""`.
              *   Add `some_content.txt` to `mockFiles`.
              *   Call `gatherDocsInternal`.
              *   Assert the resulting tag contains a document/rule with *only* the included content (and its header).

          Review existing tests in `additional_docs.test.ts` and adjust them if
          the introduction of `processMdcIncludes` changes their expected
          outcomes (it shouldn't significantly, unless they relied on exact
          content matching without includes). Ensure all mocks are properly set
          up and cleaned up.
        done: false
