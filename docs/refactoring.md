# Refactoring Approach

- **Work bottom-up**: Update utility functions first, then callers to minimize compilation errors
- **Use todo lists**: Break complex changes into trackable items for systematic progress
- **Run type checks frequently**: Catch signature mismatches early in the refactoring process
- **Make incremental commits**: Each commit should focus on a single logical change
- **Align paired implementations when touching either file**: Duplicate utility implementations can persist across mode-specific files (e.g., `normal_mode.ts` vs `simple_mode.ts`). When touching one file, check and align it with its counterpart before larger refactors
- **Consolidate shared utilities early**: When multiple modules need the same helper function, put it in `src/common/` from the start rather than duplicating it across callers and consolidating later
- **Migrate types to their new canonical location first**: When a schema file exports types used by many callers, move types to the new module and update all importers before removing the old file
- **Audit all call sites when unifying behavior**: When making multiple code paths accept the same input (e.g., treating 'cancelled' as a terminal state), check all guards that control entry into the unified function — not just the function body
- **Watch for dead code paths after data model changes**: When migrating from multi-value structures (e.g., arrays) to single-value (e.g., FK), warning/conflict logic that assumed multiple values may become permanently false — remove it rather than leaving dead branches
- **Consider all terminal states**: When a status check uses early-return for terminal states, ensure all terminal states (e.g., both `done` and `cancelled`) are handled to prevent one from being overwritten by another
- **Emit audit/log messages before side effects**: Structured audit messages should be emitted before attempting write operations, not after — otherwise audit trails have gaps when writes fail
- **Pick one authoritative layer for defensive checks**: Redundant defensive checks across multiple layers (e.g., command, executor, utility) create confusion about which layer owns the decision. Resolve the value once and trust it downstream
- **Keep dependency-inversion abstractions minimal**: When introducing a common abstraction to break a dependency cycle (e.g., `common` must not import from `tim`), keep it to just an interface and a getter/setter. The feature module registers itself; the common module only knows the interface
- **Watch for dual state tracking when extracting shared helpers**: If both the inner helper and the outer function track the same state (e.g., a `closed` flag), explicitly synchronize them to avoid misleading guards or double-cleanup
- **Blanket try-catch in shared helpers can change error semantics**: When extracting error-handling logic into a shared helper, explicit throws that were previously unhandled can get caught by a new outer catch, silently converting hard errors into soft fallbacks. Only catch specific expected failure modes (e.g., null returns), not all exceptions
- **Remove dead CLI options instead of leaving no-ops**: When a new system doesn't support a flag, remove the flag rather than keeping it as a no-op. Dead CLI options mislead users into thinking they have an effect
- **Use spread in serialization layers to avoid silently dropping new fields**: When building protocol messages or API payloads from typed objects, use spread (`{ type: 'msg', ...obj }`) rather than manually listing fields. Manual field listing silently drops any newly-added fields. Always check the serialization layer (e.g., adapter handshake) when adding fields to a protocol type, not just the builder
- **Preserve sync/async boundaries when extracting code**: When extracting a function that mixes sync and async operations (e.g., a sync OS call followed by an async shell command), keep the sync/async split in the same place as the original. Moving a sync call into an async context (or vice versa) can cause behavioral regressions like delayed execution or missed error handling
- **Verify locking assumptions when expanding code paths**: When adding operations (e.g., git commands, subprocess execution) to an existing code path, check whether surrounding locking or synchronization still covers the expanded scope. A previously lightweight unlocked phase may become a significant race window after adding heavier operations
- **Re-check assertions after deduplicating logic**: After simplifying duplicate path-computation or state-tracking into a single source, re-check defensive guards for reachability — they may have become dead code that obscures real invariants
- **Avoid control flow that depends on a no-op guard**: If correctness depends on a condition like `x === y` being true (making a branch a no-op), restructure with explicit branches instead. No-op guards are fragile and confuse future readers
- **Keep defaults identical across shared entry points**: When two or more entry points share semantics (e.g., reuse behavior), keep default parameter values identical in both paths. Otherwise users see behavior drift depending on which command they used
- **Pass computed defaults downstream, not raw optionals**: If a function computes an effective default (e.g., `shouldCreateBranch = options.createBranch ?? true`), pass the computed value to callees rather than the raw optional input — otherwise defaults can silently diverge between layers
- **Nil-coalescing (`??`) doesn't handle "present but empty string"**: Use explicit emptiness checks (`value && value.length > 0` / `!value.isEmpty`) in fallback chains involving string values rather than relying solely on `??` / nullish coalescing, which only triggers on null/undefined/nil
- **Compute old key before mutating when state determines a grouping/index key**: When an object's property determines its key in a map or ordered index, capture the old key before updating the property, then reconcile (remove stale entry if its group is now empty, insert new entry) — otherwise stale keys accumulate silently
- **Do not cache path-scoped data under only repo identity**: If a cached context includes directory-specific values (e.g., `tasksDir`), either key by that directory too or pass explicit per-call overrides to avoid stale/wrong lookups after earlier calls prime the cache
- **Update docs when reordering operations**: After reordering runtime operations (e.g., swapping lock-then-prepare vs prepare-then-lock), update workflow documentation in the same pass to keep docs in sync with behavior
- **Treat prune as destructive and parse-dependent**: If prune logic depends on parsed plan UUIDs, skip prune when any plan file fails to parse/read to avoid deleting rows for plans that still exist on disk
- **Reuse upstream error data rather than re-deriving it**: When a function already returns error tracking (e.g., an `erroredFiles` array from a scan), use that data downstream instead of performing a redundant rescan — avoids double-counting errors and unnecessary I/O
